
{{ generation_block }}

#include "../gpio.hpp"
#include "spi_{{ id }}.hpp"

void
xpcc::lpc::SpiMaster{{ id }}::configurePins(MappingSck mapping, bool useSsel)
{
	// Deassert Reset
	LPC_SYSCON->PRESETCTRL 		|= PRESETCTRL_SSP{{ id }}_RST_N;

	// Enable peripheral clock
	LPC_SYSCON->SYSAHBCLKCTRL	|= SYSAHBCLKCTRL_SSP{{ id }};

	// Divide peripheral clock by 1
	LPC_SYSCON->SSP{{ id }}CLKDIV = 0x01;

	{% if id == 0 -%}
	// MISO at PIO0_8 and MOSI at PIO0_9
	LPC_IOCON->PIO0_8			&= ~0x07;
	LPC_IOCON->PIO0_8			|=  0x01;	/* SSP MISO */
	LPC_IOCON->PIO0_9			&= ~0x07;
	LPC_IOCON->PIO0_9			|=  0x01;	/* SSP MOSI */
	{%- else -%}
	// MISO1 at PIO2_2 and MOSI1 at PIO2_3
	LPC_IOCON->PIO2_2			&= ~0x07;
	LPC_IOCON->PIO2_2			|=  0x02;	/* SSP MISO */
	LPC_IOCON->PIO2_3			&= ~0x07;
	LPC_IOCON->PIO2_3			|=  0x02;	/* SSP MOSI */
	{%- endif %}

	{% if id == 0 -%}
	// For SPI0 SCK0 can be at PIO0_6, PIO0_10 or PIO2_11
	switch (mapping)
	{
	case MappingSck::PIO0_6:
		LPC_IOCON->SCK_LOC = 0x02;
		LPC_IOCON->PIO0_6  = 0x02;	/* P0.6 function 2 is SSP clock, need to
									combined with IOCONSCKLOC register setting */
	break;
	case MappingSck::PIO0_10:
		/* This is only available if SWD/JTAG is disabled */
		LPC_IOCON->SCK_LOC = 0x00;
		LPC_IOCON->SWCLK_PIO0_10 &= ~0x07;
		LPC_IOCON->SWCLK_PIO0_10 |=  0x02;		/* SSP CLK */
	break;
	case MappingSck::PIO2_11:
		LPC_IOCON->SCK_LOC = 0x01;
		LPC_IOCON->PIO2_11 = 0x01;	/* P2.11 function 1 is SSP clock, need to
										combined with IOCONSCKLOC register setting */
	break;
	}
	{%- else -%}
	// For SPI1 SCK1 is fixed at PIO2_1
	LPC_IOCON->PIO2_1 = 0x02;
	(void) mapping; // unused
	{%- endif %}

	if (useSsel) {
	{% if id == 0 -%}
		// SSEL0 fixed at PIO0_2
		LPC_IOCON->PIO0_2 &= ~0x07;
		LPC_IOCON->PIO0_2 |=  0x01;		/* SSP SSEL */
	{%- else -%}
		// SSEL1 fixed at PIO2_0
		LPC_IOCON->PIO2_0 &= ~0x07;
		LPC_IOCON->PIO2_0 |=  0x02;
	{%- endif %}
	}

}

void
xpcc::lpc::SpiMaster{{ id }}::initialize(
		Mode mode,
		Presacler prescaler,
		uint8_t serialClockRate,
		TransferSize transferSize,
		FrameFormat frameFormat)
{
	// Control register 0
	LPC_SSP{{ id }}->CR0 = (serialClockRate << 8) |
			 (static_cast<uint16_t>(mode)) |
			((static_cast<uint16_t>(frameFormat)) << 4) |
			((static_cast<uint16_t>(transferSize)) << 0);

	// Clock prescale register
	LPC_SSP{{ id }}->CPSR = static_cast<uint8_t>(prescaler);

	for (uint8_t ii = 0; ii < fifoSize; ++ii)
	{
	  uint16_t Dummy = LPC_SSP{{ id }}->DR;		/* clear the RxFIFO */
	  (void)Dummy; // unused
	}

	/* TODO Enable the SSP Interrupt */

	// Enable SPI{{ id }} in master mode
	LPC_SSP{{ id }}->CR1 = SPI_CR1_SSE;
}

void
xpcc::lpc::SpiMaster{{ id }}::write(uint8_t data)
{
	/* Move on only if TX FIFO not full. */
	while (!(LPC_SSP{{ id }}->SR & SPI_SRn_TNF));

	/* Put data into FIFO */
	LPC_SSP{{ id }}->DR = data;
}

void
xpcc::lpc::SpiMaster{{ id }}::write(uint8_t * data, uint8_t len)
{
	while (len-- > 0)
	{
		while (!(LPC_SSP{{ id }}->SR & SPI_SRn_TNF));
		LPC_SSP{{ id }}->DR = *data;
		++data;
	}
}

bool
xpcc::lpc::SpiMaster{{ id }}::isBusy()
{
	return (LPC_SSP{{ id }}->SR & SPI_SRn_BSY);
}
