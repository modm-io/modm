// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
{{ generation_block }}

#ifndef XPCC_{{target.family | upper}}_SIMPLE_UART_SPI{{id}}_HPP
#define XPCC_{{target.family | upper}}_SIMPLE_UART_SPI{{id}}_HPP

#include "../../../device.hpp"
#include "../../uart/at90_tiny_mega/uart_defines.h"
#include <xpcc/architecture/peripheral/spi.hpp>
#include "type_ids.hpp"

namespace xpcc
{

namespace {{target.family}}
{

/**
 * Implementation of the SimpleSpi of the Uart in Spi Master mode.
 *
 * The fast SPI clock speeds make it unreasonable to use an interrupt
 * based approach to shifting out each byte of the data, since the interrupt
 * handling might decrease performance over busy waiting especially for
 * targets operating at low CPU frequencies.
 * Therefore the asynchronous methods are implemented synchronously.
 *
 * @ingroup		{{target.family}}
 * @author		Niklas Hauser
 */
class UartSpiSimpleMaster{{ id }} : public ::xpcc::SpiSimpleMaster
{
public:
	static const TypeId::UartSpiMaster{{ id }}Mosi Mosi;
	static const TypeId::UartSpiMaster{{ id }}Miso Miso;
	static const TypeId::UartSpiMaster{{ id }}Sck  Sck;

	/// Spi Data Mode, Mode0 is the most common mode
%% if extended is not defined
	/// @warning 	Only Mode 0 and 2 are available, Mode 1 and 3 are not 
	///				supported on this target.
%% endif
	enum class
	DataMode : uint8_t
	{
		Mode0 = 0,	///< clock normal,   sample on rising  edge
%% if extended is defined
		Mode1 = (1 << UCPHA{{ id }}),	///< clock normal,   sample on falling edge
%% endif
		Mode2 = (1 << UCPOL{{ id }}),	///< clock inverted, sample on falling edge
%% if extended is defined
		Mode3 = (1 << UCPOL{{ id }}) | (1 << UCPHA{{ id }}),
		///< clock inverted, sample on rising edge
%% endif
	};

	/// Spi Data Order, MsbFirst is the most common mode
	enum class
	DataOrder : uint8_t
	{
		MsbFirst = 0,
%% if extended is defined
		LsbFirst = (1 << UDORD{{ id }}),
%% else
		LsbFirst = 1,
%% endif
	};
	
public:
	// start documentation inherited
	template< class clockSource, uint32_t baudrate,
			xpcc::Tolerance tolerance = xpcc::Tolerance::FivePercent >
	static inline void
	initialize();

	static inline void
	setDataMode(DataMode mode);

%% if extended is not defined
	/// @warning 	On this target, only `DataOrder::MsbFirst` is natively
	///				supported!
	///				`DataOrder::LsbFirst` is reimplemented in software using
	///				xpcc::bitReverse(), which is quite costly.
	/// @see	xpcc::bitReverse()
%% endif
	static inline void
	setDataOrder(DataOrder order);


	static ALWAYS_INLINE uint8_t
	writeReadBlocking(uint8_t data);

%% if extended is defined
	static ALWAYS_INLINE void
	writeBlocking(uint8_t data);

	static ALWAYS_INLINE bool
	write(uint8_t data);

	static ALWAYS_INLINE bool
	getResult(uint8_t &data);
%% else
	static void
	writeBlocking(uint8_t data);

	static bool
	write(uint8_t data);

	static bool
	getResult(uint8_t &data);
%% endif

	static bool
	transfer(uint8_t *tx, uint8_t *rx, std::size_t length);

	static ALWAYS_INLINE bool
	isFinished();
	// end documentation inherited

protected:
	static void
	initialize(uint16_t prescaler);

private:
	static bool finished;
%% if extended is not defined
	static DataOrder dataOrder;
%% endif
};

} // namespace {{target.family}}

} // namespace xpcc

#include "uart_simple_spi_{{id}}_impl.hpp"

#endif // XPCC_{{target.family | upper}}_SIMPLE_UART_SPI{{id}}_HPP
