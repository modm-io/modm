// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------

#ifndef XPCC_{{target.family | upper}}_SIMPLE_UART_SPI{{id}}_HPP
#	error	"Don't include this file directly, use 'uart_simple_spi.hpp' instead!"
#endif

// ----------------------------------------------------------------------------
template< class clockSource, uint32_t baudrate, uint16_t tolerance >
void
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::initialize()
{
	constexpr uint16_t prescaler = (clockSource::UsartSpi / ( 2 * baudrate )) - 1;

	static_assert(clockSource::UsartSpi/2 >= baudrate,
			"The CPU frequency must be at least 2x higher than SPI baudrate.");
	static_assert(prescaler + 1 < (1 << 12) + 1,
			"SPI baudrate is too slow for CPU frequency (Prescaler out of bounds).");

	// check if within baudrate tolerance
	constexpr uint32_t generated_baudrate = clockSource::UsartSpi / ( 2 * prescaler + 1);
	constexpr uint32_t error = baudrate - generated_baudrate;
	static_assert(error <= baudrate * (static_cast<float>(tolerance) / 100),
			"The generated SPI baudrate is outside of specified tolerance.");

	initialize(prescaler);
}

void
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::setDataMode(DataMode mode)
{
%% if extended is defined
	UCSR{{ id }}C = (UCSR{{ id }}C & ~((1 << UCPOL{{ id }}) | (1 << UCPHA{{ id }}))) | static_cast<uint8_t>(mode);
%% else
	UCSR{{ id }}C = (UCSR{{ id }}C & ~(1 << UCPOL{{ id }})) | static_cast<uint8_t>(mode);
%% endif
}

void
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::setDataOrder(DataOrder order)
{
%% if extended is defined
	UCSR{{id}}C = (UCSR{{id}}C & ~(1 << UDORD{{id}})) | static_cast<uint8_t>(order);
%% else
	dataOrder = order;
%% endif
}

// ----------------------------------------------------------------------------
uint8_t
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::writeReadBlocking(uint8_t data)
{
	writeBlocking(data);

	uint8_t rData;
	while(!getResult(rData))
		;

	return rData;
}

%% if extended is defined
void
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::writeBlocking(uint8_t data)
{
	while(!write(data))
		;
}

bool
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::write(uint8_t data)
{
	if (!((UCSR{{id}}A & (1 << UDRE{{id}}) && finished)))
		return false;

	UDR{{id}} = data;
	return true;
}

bool
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::getResult(uint8_t &data)
{
	if (!(UCSR{{id}}A & (1 << RXC{{id}})))
		return false;

	data = UDR{{id}};
	return true;
}
%% endif

bool
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::isFinished()
{
	return ( (UCSR{{id}}A & ((1 << UDRE{{id}}) | (1 << RXC{{id}})) ) ==
			((1 << UDRE{{id}}) | (1 << RXC{{id}})) ) && finished;
}
