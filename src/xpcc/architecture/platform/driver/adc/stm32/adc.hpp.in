// coding: utf-8
/* Copyright (c) 2012, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
%#
%#
%% set channels = [0,1,2,3,4,5,6,7,8,10,11,12,13]
%% if target is stm32f2 or target is stm32f4
	%% do channels.extend([9,14,15,16,17,18])
%% elif target is stm32f1
	%% if id == 1
		%% do channels.extend([16,17])
	%% endif
	%% if id < 3
		%% do channels.extend([9,14,15])
	%% endif
%% endif
%% set channels = channels|sort
%#
%#
%% if target is stm32f2 or target is stm32f4 or (target is stm32f1 and id == 1)
	%% set temperature_available = true
%% else
	%% set temperature_available = false
%% endif
%#

#ifndef XPCC_STM32_ADC{{ id }}_HPP
#define XPCC_STM32_ADC{{ id }}_HPP

#include <stdint.h>
#include "../../../type_ids.hpp"
#include "../../../device.hpp"
#include <xpcc/architecture/interface/adc.hpp>
#include <xpcc/architecture/interface/register.hpp>


namespace xpcc
{

namespace stm32
{

/**
 * Analog/Digital-Converter module (ADC{{ id }}).
 *
 * The 12-bit ADC is a successive approximation analog-to-digital
 * converter. It has up to 18 multiplexed channels allowing it measure
 * signals from 16 external and two internal sources.
 * The result of the ADC is stored in a left-aligned or right-aligned
 * 16-bit data register.
 *
 * This API is designed for the internal ADCs of STM32F4XX,
 * STM32F10X_LD, STM32F10X_LD_VL, STM32F10X_MD, STM32F10X_MD_VL,
 * STM32F10X_HD, STM32F10X_HD_VL, STM32F10X_XL and STM32F10X_CL.
 *
 * @author	Stephan Kugelmann
 * @author	David Hebbeker
 * @author	ekiwi
 * @ingroup	stm32
 */
class Adc{{ id }} : public xpcc::Adc
{
public:
%% for channel in channels
	/// TypeId used to connect GPIO pins to this adc's Channel{{ channel }}.
	static const TypeId::Adc{{ id }}Channel{{ channel }} Channel{{ channel }};
%% endfor

public:
	/**
	 * Channels, which can be used with this ADC.
	 *
	 * You can specify the channel by using a pin-name, like PIN_C0, an
	 * internal sensor, like TEMPERATURE_SENSOR or just the plain
	 * channel number, like CHANNEL_0.
	 */
	enum class
	Channel : uint8_t	// TODO: What is the best type?
	{
%% for channel in channels
		Channel{{ channel }} = {{ channel }},
%% endfor
%#
%% if target is stm32f2 or target is stm32f4
		BatDiv2 = 18, /// Half the V_BAT voltage.
%% endif
%#
%% if temperature_available
		/** Measure the ambient temperature of the device.
		 *
		 * @li Supported temperature range: -40 to 125 C
		 * @li Precision: +-1.5 C
		 *
		 * @see Reference manual (i.e. RM0090) for the formula for the
		 * 	calculation of the actual temperature.
		 * @note The TSVREFE bit must be set to enable the conversion of
		 * 	this internal channel.
		 */
		TemperatureSensor = 16,

		/** Internal reference voltage.
		 *
		 * @note The TSVREFE bit must be set to enable the conversion of
		 * 	this internal channel.
		 */
		InternalReference = 17,
%% endif
	};

private:
	/**
	 * Programmable prescaler to divide the APB2 clock frequency, which
	 * is used for the analog circuitry (not the digital interface which
	 * is used for registers).
	 */
	enum class
	Prescaler : uint8_t
	{
		Div2 = 0b00,	///< PCLK2 divided by 2
		Div4 = 0b01,	///< PCLK2 divided by 4
		Div6 = 0b10,	///< PCLK2 divided by 6
		Div8 = 0b11		///< PCLK2 divided by 8
	};

public:
	/**
	 * Sampling time of the input voltage.
	 *
	 * Total conversion time is T_con = Sampling time + 12 cycles
	 */
	enum class
	SampleTime : uint8_t
	{
%% if target is stm32f2 or target is stm32f4
		Cycles3 	= 0b000,	///< 3 ADCCLK cycles
		Cycles15 	= 0b001,	///< 15 ADCCLK cycles
		Cycles28 	= 0b010,	///< 28 ADCCLK cycles
		Cycles56 	= 0b011,	///< 56 ADCCLK cycles
		Cycles84 	= 0b100,	///< 84 ADCCLK cycles
		Cycles112 	= 0b101,	///< 112 ADCCLK cycles
		Cycles144 	= 0b110,	///< 144 ADCCLK cycles
		Cycles480 	= 0b111		///< 480 ADCCLK cycles
%% elif target is stm32f1
		Cycles2 	= 0b000,	///< 1.5 ADCCLK cycles
		Cycles8 	= 0b001,	///< 7.5 ADCCLK cycles
		Cycles14 	= 0b010,	///< 13.5 ADCCLK cycles
		Cycles29 	= 0b011,	///< 28.5 ADCCLK cycles
		Cycles42 	= 0b100,	///< 41.5 ADCCLK cycles
		Cycles56 	= 0b101,	///< 55.5 ADCCLK cycles
		Cycles72 	= 0b110,	///< 71.5 ADCCLK cycles
		Cycles240 	= 0b111		///< 239.5 ADCCLK cycles
%% endif
	};

	/**
	 * Possible interrupts.
	 *
	 * An interrupt can be produced on the end of conversion for regular
	 * and injected groups, when the analog watchdog status bit is set
	 * and when the overrun status bit is set.
	 */
	enum class
	Interrupt : uint32_t
	{
		/// Analog watchdog status bit is set
		AnalogWatchdog			= ADC_CR1_AWDIE,
		/// End of conversion of a regular group
		EndOfRegularConversion	= ADC_CR1_EOCIE,
		/// End of conversion of an injected group
		EndOfInjectedConversion	= ADC_CR1_JEOCIE,
%% if target is stm32f2 or target is stm32f4
		/// Overrun (if data are lost)
		Overrun					= ADC_CR1_OVRIE,
%% endif
	};
	XPCC_FLAGS32(Interrupt);

	enum class
	InterruptFlag : uint32_t
	{
		/// Analog watchdog status bit is set
		AnalogWatchdog			= ADC_SR_AWD,
		/// End of conversion of a regular group
		EndOfRegularConversion	= ADC_SR_EOC,
		/// End of conversion of an injected group
		EndOfInjectedConversion	= ADC_SR_JEOC,
%% if target is stm32f2 or target is stm32f4
		/// Overrun (if data are lost)
		Overrun					= ADC_SR_OVR,
		/// All InterruptFlags
		All				= ADC_SR_AWD | ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR,
%% else
		/// All InterruptFlags
		All						= ADC_SR_AWD | ADC_SR_EOC | ADC_SR_JEOC,
%% endif
	};
	XPCC_FLAGS32(InterruptFlag);

public:
	// start documentation inherited
	/**
	 * Initialize and enable the A/D converter.
	 *
	 * Enables the ADC clock and switches on the ADC. The ADC clock
	 * prescaler will be set as well.
	 *
	 * The ADC clock must not exceed 14 MHz. Default is a prescaler
	 * of 8 which gives a 9 Mhz ADC clock at 72 MHz APB2 clock.
	 *
	 * @param prescaler
	 * 		The prescaler specifies by which factor the
	 * 		APB2 clock (72 MHz) will be divided.
	 */
	template< class clockSource, uint32_t frequency=10000000,
			uint16_t tolerance = xpcc::Tolerance::TenPercent >
	static void
	initialize();

	static inline void
	disable();

	/**
	 * Start a new conversion or continuous conversions.
	 *
	 * @pre A ADC channel must be selected with setChannel(). When using
	 * 	a STM32F10x a delay of at least t_STAB after initialize() must
	 * 	be waited!
	 *
	 * @post The result can be fetched with getValue()
	 * @attention When using a STM32F10x, the application should allow a delay of t_STAB between
	 * 	power up and start of conversion. Refer to Reference Manual
	 * 	(RM0008) ADC_CR2_ADON.
	 */
	static inline void
	startConversion();

	static inline bool
	isConversionFinished();

	static inline uint16_t
	getValue();


	static uint16_t
	readChannel(Channel channel);


	/**
	 * Analog channel selection.
	 *
	 * This not for scan mode. The number of channels will be set to 1,
	 * the channel selected and the corresponding pin will be set to
	 * analog input.
	 * If the the channel is modified during a conversion, the current
	 * conversion is reset and a new start pulse is sent to the ADC to
	 * convert the new chosen channnel / group of channels.
	 *
	 *
	 * @param channel		The channel which shall be read.
	 * @param sampleTime	The sample time to sample the input voltage.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 		initialize()
	 */
	static inline bool
	setChannel(const Channel channel,
			   const SampleTime sampleTime = static_cast<SampleTime>(0b000));

	static Channel
	getChannel();


	static inline void
	enableFreeRunningMode();

	static inline void
	disableFreeRunningMode();


	static inline void
	setLeftAdjustResult();

	static inline void
	setRightAdjustResult();
	// stop documentation inherited

	// TODO
	//static void
	//calibrate();


%% if temperature_available
	/// Switch on temperature- and V_REF measurement.
	static inline void
	enableTemperatureRefVMeasurement();

	/// Switch on temperature- and V_REF measurement.
	static inline void
	disableTemperatureRefVMeasurement();
%% endif


	/// Add a channel to conversion group.
	static inline bool
	addChannel(const Channel channel,
		const SampleTime sampleTime = static_cast<SampleTime>(0b000));

	/// change sample time of ADC channel
	static inline void
	setSampleTime(const Channel channel,
		const SampleTime sampleTime = static_cast<SampleTime>(0b000));


	static inline void
	enableInterruptVector(const uint32_t priority, const bool enable = true);

	/**
	 * Enables the ADC Conversion Complete Interrupt.
	 *
	 * You could catch the interrupt using this example function:
	 * @li for STM32F4XX: `extern "C" void ADC_IRQHandler()`
	 * @li for STM32F10X: `extern "C" void ADC1_2_IRQHandler()`
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 	initialize(). Also the Interrupt Vector needs to be enabled first.
	 *
	 * @param priority Priority to set
	 * @param interrupt The interrupt, which shall be enabled. See
	 * 	Interrupt for available interrupts.
	 *
	 * @note ADC1 and ADC2 interrupts are mapped onto the same interrupt
	 * 	vector. ADC3 interrupts are mapped onto a separate interrupt
	 * 	vector.
	 */
	static inline void
	enableInterrupt(const Interrupt_t interrupt);

	/**
	 * Disables the ADC Conversion Complete Interrupt.
	 */
	static inline void
	disableInterrupt(const Interrupt_t interrupt);


	/**
	 * Returns if the th interrupt flags set.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 	initialize()
	 */
	static inline InterruptFlag_t
	getInterruptFlags();

	/**
	 * Clears the specified interrupt flag.
	 *
	 * @param flag
	 * 		The interrupt flag, which shall be cleared.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 		initialize().
	 */
	static inline void
	acknowledgeInterruptFlags(const InterruptFlag_t flags);

private:
	/**
	 * Select the frequency of the clock to the ADC. The clock is common
	 * for all the ADCs (ADC1, ADC2, ADC3) and all channels.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 	initialize()
	 *
	 * @param prescaler
	 * 		The prescaler specifies by which factor the system clock
	 * 		will be divided.
	 */
	static inline void
	setPrescaler(const Prescaler prescaler = Prescaler::Div8);
};

} // namespace stm32

} // namespace xpcc

#include "adc_{{ id }}_impl.hpp"

#endif	// XPCC_STM32_ADC{{ id }}_HPP

