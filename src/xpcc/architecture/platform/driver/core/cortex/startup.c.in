// coding: utf-8
// ----------------------------------------------------------------------------
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *	 * Redistributions of source code must retain the above copyright
 *	   notice, this list of conditions and the following disclaimer.
 *	 * Redistributions in binary form must reproduce the above copyright
 *	   notice, this list of conditions and the following disclaimer in the
 *	   documentation and/or other materials provided with the distribution.
 *	 * Neither the name of the Roboterclub Aachen e.V. nor the
 *	   names of its contributors may be used to endorse or promote products
 *	   derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// ----------------------------------------------------------------------------
%# This global dict accepts platform specific peripheral interrupts
%# generated by the platform.startupHeader macro
%% set i = {}
%# Generate Cortex Interrupts
%% if target is cortex_m3 or target is cortex_m4 or target is cortex_m7
%% 	do i.update({-12:  ["MemManage_Handler", "MPU Fault Handler"]})
%% 	do i.update({-11:  ["BusFault_Handler", "Bus Fault Handler"]})
%% 	do i.update({-10:  ["UsageFault_Handler", "Usage Fault Handler"]})
%% 	do i.update({ -4: ["DebugMon_Handler", "Debug Monitor Handler"]})
%% endif
%% do i.update({-5: ["SVC_Handler", "SVCall Handler"]})
%% do i.update({-2: ["PendSV_Handler", "PendSV Handler"]})
%% do i.update({-1: ["SysTick_Handler", "SysTick Handler"]})
%# Include Target Specific Files
%% if target is stm32
%%	import 'stm32/stm32.macros' as platform with context
%% elif target is lpc
%%	import 'lpc/lpc.macros' as platform with context
%% endif
%# Set peripheralInterrupts variable that contains device specific interrupts
{{ platform.appendInterrupts() }}
%# Count Interrupts
%% set number_of_interrupts = i.keys()|sort|last

#include <stdint.h>
#include <xpcc/architecture/utils.hpp>
#include "../../../device.hpp"
#include "xpcc_config.hpp"

// ----------------------------------------------------------------------------
{{ platform.defines() }}

// ----------------------------------------------------------------------------
/*
 * Provide weak aliases for each Exception handler to defaultHandler.
 * As they are weak aliases, any function with the same name will override
 * this definition.
 */
void Reset_Handler(void)				__attribute__((naked, noreturn));
void NMI_Handler(void)					__attribute__ ((weak, alias("defaultHandler")));
%% if target is cortex_m3 or target is cortex_m4 or target is cortex_m7
void HardFault_Handler(void);
%% elif target is cortex_m0
%# for cortex m0 no hard fault handler is implemented
void HardFault_Handler(void)			__attribute__ ((weak, alias("defaultHandler")));
%% endif
%# Remember declarations to avoid redeclarations
%% set declarations = []
%% for addr, interrupt in i.iteritems()
%% 	if interrupt[0] not in declarations
%%		do declarations.append(interrupt[0])
%%		set suffix = "_IRQHandler"
%%		if addr < 0
%%			set suffix = ""
%%		endif
{{ ("void " + interrupt[0] + suffix + "(void)") | xpcc.pad(36)}}__attribute__ ((weak, alias("defaultHandler")));
%%	endif
%% endfor
// ----------------------------------------------------------------------------
// Interrupt vectors
typedef void (* const FunctionPointer)(void);

// defined in the linkerscript
extern uint32_t __main_stack_top;
extern uint32_t __process_stack_top;

%% if parameters.vector_table_in_ram
// Define the vector table
FunctionPointer flashVectors[4] __attribute__ ((section(".reset"))) =
{
	(FunctionPointer) &__main_stack_top,	// stack pointer
	Reset_Handler,				// code entry point
	NMI_Handler,				// NMI handler
	HardFault_Handler,			// hard fault handler
};

FunctionPointer ramVectors[] __attribute__ ((section(".vectors"))) =
%% else
FunctionPointer flashVectors[] __attribute__ ((section(".reset"))) =
%% endif
{
	(FunctionPointer) &__main_stack_top,	// -16: stack pointer
	Reset_Handler,							// -15: code entry point
	NMI_Handler,							// -14: Non Maskable Interrupt handler
	HardFault_Handler,						// -13: hard fault handler
%% for addr in range(4 - 16, number_of_interrupts + 1)
%% 	if addr in i
%%		set suffix = "_IRQHandler"
%%		if addr < 0
%%			set suffix = ""
%%		endif
	{{ (i[addr][0] + suffix + ",") | xpcc.pad(36) }}// {{addr}}
%% 	else
	0,										// {{addr}}
%% 	endif
%% endfor
};

// ----------------------------------------------------------------------------
// The following are constructs created by the linker, indicating where the
// the "data" and "bss" segments reside in memory.  The initializers for the
// for the "data" segment resides immediately following the "text" segment.
extern uint32_t __stack_start;
extern uint32_t __stack_end;

extern uint32_t __fastcode_load;
extern uint32_t __fastcode_start;
extern uint32_t __fastcode_end;

extern uint32_t __vector_table_ram_load;
extern uint32_t __vector_table_ram_start;
extern uint32_t __vector_table_ram_end;

extern uint32_t __vector_table_rom_start;

extern uint32_t __fastdata_load;
extern uint32_t __fastdata_start;
extern uint32_t __fastdata_end;

extern uint32_t __data_load;
extern uint32_t __data_start;
extern uint32_t __data_end;

extern uint32_t __bss_start;
extern uint32_t __bss_end;

// Application's main function
int
main(void);

// calls CTORS of static objects
void
__libc_init_array(void);

extern void
exit(int) __attribute__ ((noreturn, weak));

%% if parameters.allocator == "block_allocator"
extern void __xpcc_initialize_memory(void);
%% endif

%% if parameters.enable_gpio
extern void xpcc_gpio_enable(void);
%% endif

// ----------------------------------------------------------------------------
// This is the code that gets called when the processor first starts execution
// following a reset event.  Only the absolutely necessary set is performed,
// after which the application supplied main() routine is called.  Any fancy
// actions (such as making decisions based on the reset cause register, and
// resetting the bits in that register) are left solely in the hands of the
// application.
void
Reset_Handler(void)
{
	// fill the stack with 0xAAAA5555 for watermarking
	asm volatile (
		".syntax unified"         "\n\t"
		"ldr  r0, =__stack_start" "\n\t"
		"ldr  r1, =__stack_end-4" "\n\t"
		"ldr  r2, =0xAAAA5555"    "\n\t"
	"1:  str  r2, [r0]"           "\n\t" // store the value into ram
		"adds r0, #4"             "\n\t" // add sizeof(uint32_t) to the pointer
		"cmp  r0, r1"             "\n\t" // compare pointer with end of stack address
		"bne  1b"                 "\n\t" // continue loop if not equal
	);

	uint32_t* src;
	uint32_t* dest;

%% if parameters.vector_table_in_ram
	// copy vector table to RAM (.vectors)
	src = &__vector_table_ram_load;
	dest = &__vector_table_ram_start;
	while (dest < &__vector_table_ram_end)
	{
		*(dest++) = *(src++);
	}
%% endif

	// Copy functions to RAM (.fastcode)
	src = &__fastcode_load;
	dest = &__fastcode_start;
	while (dest < &__fastcode_end)
	{
		*(dest++) = *(src++);
	}

	src = &__fastdata_load;
	dest = &__fastdata_start;
	while (dest < &__fastdata_end)
	{
		*(dest++) = *(src++);
	}

	// Copy the data segment initializers from flash to RAM (.data)
	src = &__data_load;
	dest = &__data_start;
	while (dest < &__data_end)
	{
		*(dest++) = *(src++);
	}

	// Fill the bss segment with zero (.bss)
	dest = &__bss_start;
	while (dest < &__bss_end)
	{
		*(dest++) = 0;
	}

%# Perform Platform Specific Setup
{{ platform.startupCode() }}

%% if not target is cortex_m0
	// Enable Tracing Debug Unit
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
	DWT->CYCCNT = 0;
	// Enable CPU cycle counter
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
%% endif

%% if target is cortex_m4f or target is cortex_m7f
	// Enable FPU in privileged and user mode
	SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));  // set CP10 and CP11 Full Access
%% endif

%% if target is cortex_m3 or target is cortex_m4 or target is cortex_m7
	// Setup NVIC
	// Set vector table
	%% if parameters.vector_table_in_ram
	SCB->VTOR = (uint32_t)(&__vector_table_ram_start);
	%% else
	SCB->VTOR = (uint32_t)(&__vector_table_rom_start);
	%% endif
	// Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
	// This applies to the hard fault, NMI, and FAULTMASK escalated handlers.
	// We use this to opportunistically restore LR, PC and xPSR in the hard fault handler.
	// Also enables trapping of divide by zero. Otherwise it would just be ignored.
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk | SCB_CCR_DIV_0_TRP_Msk;

	// Lower priority level for all peripheral interrupts to lowest possible
	for (uint32_t i = 0; i < {{ number_of_interrupts }}; i++) {
		NVIC->IP[i] = 0xff;
	}

	// Set the PRIGROUP[10:8] bits to
	// - 4 bits for pre-emption priority,
	// - 0 bits for subpriority
	SCB->AIRCR = 0x05FA0000 | 0x300;

	// Enable fault handlers
	/*SCB->SHCSR |=
			SCB_SHCSR_BUSFAULTENA_Msk |
			SCB_SHCSR_USGFAULTENA_Msk |
			SCB_SHCSR_MEMFAULTENA_Msk;*/
%% endif

%% if parameters.enable_gpio
	// Enable GPIO Clock
	xpcc_gpio_enable();
%% endif

%% if parameters.allocator == "block_allocator"
	// initialize xpcc block allocator
	// needs to be done before calling the CTORS of static objects
	__xpcc_initialize_memory();
%% endif

	// Call CTORS of static objects
	__libc_init_array();

	// Call the application's entry point
	main();

	exit(1);

	while (1)
	{
	}
}

// ----------------------------------------------------------------------------
/**
 * @brief	Default interrupt handler
 *
 * This functions gets called if an interrupt handler is not defined. It just
 * enters an infinite loop leaving the processor state intact for a debugger
 * to be examined.
*/
void
defaultHandler(void)
{
	while (1)
	{
	}
}
