/*
 * Copyright (c) 2019, Mike Wolfram
 * Copyright (c) 2021, Thomas Sommer
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
#pragma once
#include "ili9341.hpp"

#include <modm/architecture/interface/spi_device.hpp>
#include <modm/processing/resumable.hpp>

#include "ili9341_defines.hpp"

namespace modm
{

// TODO Forward Nesting Level from PainterRemote: template<class Spi, class Cs, class Dc, int Levels = 4>
/// @ingroup modm_driver_ili9341
template<class Spi, class Cs, class Dc>
class Ili9341InterfaceSpi : public ili9341_register, public modm::SpiDevice< Spi >, protected modm::NestedResumable<5>
{
	uint8_t read;

protected:
	Ili9341InterfaceSpi()
	{
		this->attachConfigurationHandler([]() {
			Spi::setDataMode(Spi::DataMode::Mode0);
			Spi::setDataOrder(Spi::DataOrder::MsbFirst);
		});

		Cs::setOutput(modm::Gpio::High);
		Dc::setOutput();
	}

// - Configure display controller --------------------------------

	modm::ResumableResult<void>
	writeCommand(Command command)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit8);
	%% endif

		Dc::reset();
		RF_CALL(Spi::transmit(uint8_t(command)));
		Dc::set();

		if (this->releaseMaster())
			Cs::set();

		RF_END();
	}

	template<modm::unsigned_integral_max16 T>
	modm::ResumableResult<void>
	writeCommand(Command command, const T data)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit8);
	%% endif

		Dc::reset();
		RF_CALL(Spi::transmit(uint8_t(command)));
		Dc::set();

	%% if spi_16bit_hardware
		if constexpr(std::is_same<T, uint16_t>::value)
			Spi::setDataSize(Spi::DataSize::Bit16);
	%% endif

		RF_CALL(Spi::transmit(data));

		if (this->releaseMaster())
			Cs::set();

		RF_END();
	}

	template<modm::unsigned_integral_max16 T>
	modm::ResumableResult<void>
	writeCommand(Command command, const T *data_first, const T *data_last)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit8);
	%% endif

		Dc::reset();
		RF_CALL(Spi::transmit(uint8_t(command)));
		Dc::set();

	%% if spi_16bit_hardware
		if constexpr(std::is_same<T, uint16_t>::value)
			Spi::setDataSize(Spi::DataSize::Bit16);
	%% endif

		RF_CALL(Spi::transmit(data_first, data_last));

		if (this->releaseMaster())
			Cs::set();

		RF_END();
	}

	modm::ResumableResult<void>
	writeCommand(Command command, const uint16_t *data, uint16_t length)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit8);
	%% endif

		Dc::reset();
		RF_CALL(Spi::transmit(uint8_t(command)));
		Dc::set();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit16);
	%% endif

		RF_CALL(Spi::transfer16(data, nullptr, length));

		if (this->releaseMaster())
			Cs::set();

		RF_END();
	}

	modm::ResumableResult<uint8_t>
	readData(Command command)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();
	
	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit8);
	%% endif

		Dc::reset();
		RF_CALL(Spi::transmit(uint8_t(command)));
		Dc::set();

		// REIMPLEMENT
		// read = RF_CALL(Spi::transmit(0)).getResult();

		if (this->releaseMaster())
			Cs::set();

		RF_END_RETURN(read);
	}

	template<modm::unsigned_integral_max16 T>
	modm::ResumableResult<void>
	readData(Command command, T *data_first, T *data_last)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit8);
	%% endif

		Dc::reset();
		RF_CALL(Spi::transmit(uint8_t(command)));
		Dc::set();

	%% if spi_16bit_hardware
		if constexpr(std::is_same<T, uint16_t>::value)
			Spi::setDataSize(Spi::DataSize::Bit16);
	%% endif

		// REIMPLEMENT
		// RF_CALL(Spi::receive(data_first, data_last));

		if (this->releaseMaster())
			Cs::set();

		RF_END();
	}

// - Write / Read CGRAM ----------------------------------------


	modm::ResumableResult<void>
	writePixel(color::Rgb565 pixel)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit8);
	%% endif

		RF_CALL(Spi::transmit(pixel.getValue()));

		if (this->releaseMaster())
			Cs::set();

		RF_END();
	}

	modm::ResumableResult<void>
	writePixels(color::Rgb565 pixel, uint16_t repeat)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit16);
	%% endif

		RF_CALL(Spi::transmit(pixel.getValue(), repeat));

		if (this->releaseMaster())
			Cs::set();

		RF_END();
	}

	modm::ResumableResult<void>
	writePixels(const color::Rgb565 *pixel_first, const color::Rgb565 *pixel_last)
	{
		RF_BEGIN();

		RF_WAIT_UNTIL(this->acquireMaster());
		Cs::reset();

	%% if spi_16bit_hardware
		Spi::setDataSize(Spi::DataSize::Bit16);
	%% endif

		RF_CALL(Spi::transmit((uint16_t*)(pixel_first), (uint16_t*)(pixel_last)));

		if (this->releaseMaster())
			Cs::set();

		RF_END();
	}
};

}  // namespace modm