/*
 * Copyright (c) 2021, Raphael Lehmann
 * Copyright (c) 2021, Thomas Sommer
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#pragma once
#include "touch2046.hpp"

#include <modm/math/utils/endianness.hpp>

template<class SpiMaster, class Cs, Size R>
modm::Touch2046<SpiMaster, Cs, R>::Touch2046()
{
	this->attachConfigurationHandler([]() {
		SpiMaster::setDataMode(SpiMaster::DataMode::Mode0);
		SpiMaster::setDataOrder(SpiMaster::DataOrder::MsbFirst);
	%% if spi_16bit_hardware
		SpiMaster::setDataSize(SpiMaster::DataSize::Bit16);
	%% endif
	});

	Cs::setOutput(true);
}

template<class SpiMaster, class Cs, Size R>
modm::ResumableResult<void>
modm::Touch2046<SpiMaster, Cs, R>::updateZ()
{
	RF_BEGIN();

	RF_WAIT_UNTIL(this->acquireMaster());
	Cs::reset();

	RF_CALL(SpiMaster::transfer16(&bufferWrite[0], &bufferRead[0], 3));

	z = 4095 + (bufferRead[1] >> 3) - (bufferRead[2] >> 3);

	if (this->releaseMaster())
		Cs::set();

	RF_END_RETURN();
}

template<class SpiMaster, class Cs, Size R>
modm::ResumableResult<void>
modm::Touch2046<SpiMaster, Cs, R>::updateXY()
{
	RF_BEGIN();

	RF_WAIT_UNTIL(this->acquireMaster());
	Cs::reset();

	RF_CALL(SpiMaster::transfer16(&bufferWrite[2], &bufferRead[0], bufferRead.size()));

	if (this->releaseMaster())
		Cs::set();

	x = (bufferRead[1] >> 3) + (bufferRead[3] >> 3) + (bufferRead[5] >> 3);
	y = (bufferRead[2] >> 3) + (bufferRead[4] >> 3) + (bufferRead[6] >> 3);

	static constexpr int scale_shift = 10;
	x = std::clamp<int16_t>((((uint32_t)(x * cal.FactorX) >> scale_shift) + cal.OffsetX), 0, R.x);
	y = std::clamp<int16_t>((((uint32_t)(y * cal.FactorY) >> scale_shift) + cal.OffsetY), 0, R.y);

	RF_END_RETURN();
}

template<class SpiMaster, class Cs, Size R>
modm::ResumableResult<bool>
modm::Touch2046<SpiMaster, Cs, R>::isTouched()
{
	RF_BEGIN();
	RF_CALL(updateZ());
	RF_END_RETURN(z > cal.ThresholdZ);
}

template<class SpiMaster, class Cs, Size R>
modm::ResumableResult<modm::shape::Point>
modm::Touch2046<SpiMaster, Cs, R>::getTouchPoint()
{
	RF_BEGIN();
	RF_CALL(updateXY());

	switch(orientation) {
		case Orientation::Landscape0: RF_RETURN(Point(R.y - y, R.x - x));
		case Orientation::Portrait90: RF_RETURN(Point(x, R.y - y));
		case Orientation::Landscape180: RF_RETURN(Point(y, x));
		case Orientation::Portrait270: RF_RETURN(Point(R.x - x, y));
	}

	RF_END();
}

template<class SpiMaster, class Cs, Size R>
modm::ResumableResult<std::tuple<uint16_t, uint16_t>>
modm::Touch2046<SpiMaster, Cs, R>::getTouchPosition()
{
	RF_BEGIN();
	RF_CALL(updateXY());
	// TODO evaluate orientation & modm::graphic::OrientationFlags::TopDown
	if (orientation & modm::graphic::OrientationFlags::Portrait) {
		RF_RETURN(std::make_tuple(x, y));
	} else {
		RF_RETURN(std::make_tuple(y, x));
	}
	RF_END();
}