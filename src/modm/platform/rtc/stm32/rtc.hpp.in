/*
 * Copyright (c) 2023, Rasmus Kleist Hørlyck Sørensen
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_RTC_HPP
#define MODM_STM32_RTC_HPP

#include <chrono>

#include <modm/architecture/interface/clock.hpp>
#include <modm/architecture/interface/register.hpp>
#include <modm/platform/clock/rcc.hpp>

namespace modm::platform
{

/**
 * Real Time Clock (RTC) control for STM32 devices
 *
 * @author Rasmus Kleist Hørlyck Sørensen
 * @ingroup modm_platform_rtc
 */
class Rtc
{
    using duration = std::chrono::duration<int64_t>;
    using rep = duration::rep;
    using period = duration::period;
    using time_point = std::chrono::time_point<Rtc, duration>;

public:

    /// prescalars
    struct modm_packed
    Prescaler
    {
        constexpr Prescaler() : asynchronous(0x7F), synchronous(0xFF) {}
        constexpr Prescaler(uint16_t asynchronous, uint16_t synchronous) :
            asynchronous(asynchronous),
            synchronous(synchronous)
        {
        }

        uint16_t asynchronous;
        uint16_t synchronous;
    };

    /// TODO: Use std::tm instead
    struct modm_packed
    DateTime
    {
        uint8_t year;
        uint8_t month;
        uint8_t date;
        uint8_t weekday;
        uint8_t hour;
        uint8_t minute;
        uint8_t second;
    };

public:
    static void
    enable();

    static void
    disable();

    /**
     * @brief
     *
     * @param time
     * @param prediv
     * @attention the APB1 clock frequency must be equal to or greater than seven times the RTC clock frequency
     */
    static bool
    initialize(const DateTime datetime, const Prescaler prescaler = Prescaler(), uint32_t waitCycles = 2048);

    /**
     * @brief
     *
     * @param delay
     */
    template< typename Rep, typename Period >
    static bool
    synchronize(std::chrono::duration<Rep, Period> delay, uint32_t waitCycles = 2048);

    /**
     * @brief
     *
     */
    static bool
    getDateTime(DateTime &dateTime, uint32_t waitCycles = 2048);

    /**
     * @brief Get the subsecond second used for synchronization
     *
     * @return float
     */
    static bool
    getSubSecond(float &subsecond, uint32_t waitCycles = 2048);

public:

    enum class
    Interrupt : uint32_t
    {
        InternalTimestamp = RTC_CR_ITSE,
        Timestamp = RTC_CR_TSIE,
        WakeupTimer = RTC_CR_WUTIE,
        AlarmB = RTC_CR_ALRBIE,
        AlarmA = RTC_CR_ALRAIE,
    };
    MODM_FLAGS32(Interrupt);

    enum class
    InterruptFlag : uint32_t
    {
        InternalTimestamp = RTC_SR_ITSF,
        TimestampOverflow = RTC_SR_TSOVF,
        Timestamp = RTC_SR_TSF,
        WakeupTimer = RTC_SR_WUTF,
        AlarmB = RTC_SR_ALRBF,
        AlarmA = RTC_SR_ALRAF,
    };
    MODM_FLAGS32(InterruptFlag);

    static void
    enableInterruptVector(bool enable, uint32_t priority);

    static void
    enableInterrupt(Interrupt_t interrupt);

    static void
    disableInterrupt(Interrupt_t interrupt);

    static InterruptFlag_t
    getInterruptFlags();

    /**
     *
     *
     * @warning 	Not all InterruptFlags can be cleared this way.
     */
    static void
    acknowledgeInterruptFlag(InterruptFlag_t flags);

private:
    inline static void
    unlock();

    inline static void
    lock();

    inline static uint16_t
    getAsynchronousPrescaler();

    inline static uint16_t
    getSynchronousPrescaler();

    static inline uint32_t ck_apre{0}; // RTCCLK frequency / (PREDIV_A+1)
    static inline uint32_t ck_spre{0}; // ck_apre frequency / (PREDIV_S+1)

    friend class modm::chrono::milli_clock;
	friend class modm::chrono::micro_clock;
};

} // namespace modm::platform

#include "rtc_impl.hpp"

#endif // MODM_STM32_RTC_HPP
