/*
 * Copyright (c) 2023, Rasmus Kleist Hørlyck Sørensen
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#include "rtc.hpp"

#include <modm/math/utils.hpp>

namespace modm::platform
{

// ----------------------------------------------------------------------------

void
Rtc::enable()
{
    Rcc::enable<Peripheral::Rtc>();
}

// ----------------------------------------------------------------------------

void
Rtc::disable()
{
    Rcc::disable<Peripheral::Rtc>();
}

// ----------------------------------------------------------------------------

bool
Rtc::initialize(const DateTime dateTime, const Prescaler prescaler, uint32_t waitCycles)
{
    /// TODO: Assert that RTC frequency is less than APB1 frequency

    enable();
    unlock();

    // Enter initialization mode
    RTC->ICSR |= RTC_ICSR_INIT;

    // Wait until initialization phase mode is entered when INITF bit is set
    while (!(RTC->ICSR & RTC_ICSR_INITF))
        if (--waitCycles == 0) return false;

    // To generate a 1 Hz clock for the calendar counter, program both the prescaler factors
    RTC->PRER = ((prescaler.asynchronous << RTC_PRER_PREDIV_A_Pos) & RTC_PRER_PREDIV_A_Msk) |
                ((prescaler.synchronous << RTC_PRER_PREDIV_S_Pos) & RTC_PRER_PREDIV_S_Msk);

    // Configure 24 hour format
    RTC->CR &= ~RTC_CR_FMT;

    // Load the time in 24 hour format into the shadow registers
    RTC->TR = ((toBcd(dateTime.hour) << RTC_TR_HU_Pos) & (RTC_TR_HT_Msk | RTC_TR_HU_Msk)) |
              ((toBcd(dateTime.minute) << RTC_TR_MNU_Pos) & (RTC_TR_MNT_Msk | RTC_TR_MNU_Msk)) |
              ((toBcd(dateTime.second) << RTC_TR_SU_Pos) & (RTC_TR_ST_Msk | RTC_TR_SU_Msk));

    // Load the date in the shadow registers
    RTC->DR = ((toBcd(dateTime.year) << RTC_DR_YU_Pos) & (RTC_DR_YT_Msk | RTC_DR_YU_Msk)) |
              ((toBcd(dateTime.month) << RTC_DR_MU_Pos) & (RTC_DR_MT_Msk | RTC_DR_MU_Msk)) |
              ((toBcd(dateTime.date) << RTC_DR_DU_Pos) & (RTC_DR_DT_Msk | RTC_DR_DU_Msk)) |
              ((dateTime.weekday << RTC_DR_WDU_Pos) & RTC_DR_WDU_Msk);

    // Exit the initialization mode by clearing the INIT bit
    RTC->ICSR &= ~RTC_ICSR_INIT;

    lock();

    return true;
}

// ----------------------------------------------------------------------------

bool
Rtc::getDateTime(DateTime &dateTime, uint32_t waitCycles)
{
    /// TODO: Determine if ABP1 frequency is less than seven times RTC frequency
    /// TODO: Determine if BYPSHAD control bit is set or cleared in the RTC_CR register

    // After initialization, synchronization software must wait until RSF is set
    while (!(RTC->ICSR & RTC_ICSR_RSF))
        if (--waitCycles == 0) return false;

    dateTime.hour     = fromBcd((RTC->TR & (RTC_TR_HT_Msk | RTC_TR_HU_Msk)) >> RTC_TR_HU_Pos);
    dateTime.minute   = fromBcd((RTC->TR & (RTC_TR_MNT_Msk | RTC_TR_MNU_Msk)) >> RTC_TR_MNU_Pos);
    dateTime.second   = fromBcd((RTC->TR & (RTC_TR_ST_Msk | RTC_TR_SU_Msk)) >> RTC_TR_SU_Pos);

    dateTime.year     = fromBcd((RTC->DR & (RTC_DR_YT_Msk | RTC_DR_YU_Msk)) >> RTC_DR_YU_Pos);
    dateTime.month    = fromBcd((RTC->DR & (RTC_DR_MT_Msk | RTC_DR_MU_Msk)) >> RTC_DR_MU_Pos);
    dateTime.date     = fromBcd((RTC->DR & (RTC_DR_DT_Msk | RTC_DR_DU_Msk)) >> RTC_DR_DU_Pos);
    dateTime.weekday  = ((RTC->DR & RTC_DR_WDU_Msk) >> RTC_DR_WDU_Pos);

    return true;
}

// ----------------------------------------------------------------------------

bool
Rtc::getSubSecond(float &subsecond, uint32_t waitCycles)
{
    // After initialization, synchronization software must wait until RSF is set
    while (!(RTC->ICSR & RTC_ICSR_RSF))
        if (--waitCycles == 0) return false;

    uint32_t predivS = getSynchronousPrescaler();
    uint32_t ss = (RTC->SSR & RTC_SSR_SS_Msk) >> RTC_SSR_SS_Pos;
    subsecond = float(predivS - ss) / float(predivS + 1);
    /// TODO: Handle case when ss > predivS

    return true;
}

// ----------------------------------------------------------------------------

void
Rtc::getPrescaler(Prescaler &prescaler)
{
    prescaler.asynchronous = getAsynchronousPrescaler();
    prescaler.synchronous  = getSynchronousPrescaler();
}

// ----------------------------------------------------------------------------

void inline
Rtc::enableInterruptVector(bool enable, uint32_t priority)
{
    /// TODO: Some devices only have a single RTC interrupt register
    if (enable) {
        // Set priority for the interrupt vector
        NVIC_SetPriority(RTC_TAMP_LSECSS_IRQn, priority);
        NVIC_SetPriority(RTC_WKUP_IRQn, priority);
        // register IRQ at the NVIC
        NVIC_EnableIRQ(RTC_TAMP_LSECSS_IRQn);
        NVIC_EnableIRQ(RTC_WKUP_IRQn);
    }
    else {
        NVIC_DisableIRQ(RTC_TAMP_LSECSS_IRQn);
        NVIC_DisableIRQ(RTC_WKUP_IRQn);
    }
}

// ----------------------------------------------------------------------------

void inline
Rtc::enableInterrupt(Interrupt_t interrupt)
{
    RTC->CR |= interrupt.value;
}

// ----------------------------------------------------------------------------

void inline
Rtc::disableInterrupt(Interrupt_t interrupt)
{
    RTC->CR &= ~interrupt.value;
}

// ----------------------------------------------------------------------------

Rtc::InterruptFlag_t inline
Rtc::getInterruptFlags()
{
    return InterruptFlag_t(RTC->SR);
}

// ----------------------------------------------------------------------------

void inline
Rtc::acknowledgeInterruptFlag(InterruptFlag_t flags)
{
    RTC->SCR |= flags.value;
}

// ----------------------------------------------------------------------------

void
Rtc::unlock()
{
    // DBP bit must be set in order to enable RTC registers write access.
    PWR->CR1 |= PWR_CR1_DBP;

    // Unlock the write protection on the protected RTC registers.
    RTC->WPR = 0xCA;
    RTC->WPR = 0x53;
}

// ----------------------------------------------------------------------------

void
Rtc::lock()
{
    // Lock the write protection on the protected RTC registers.
    RTC->WPR = 0x00;

    // DBP bit must be reset in order to disable RTC registers write access.
    PWR->CR1 &= ~PWR_CR1_DBP;
}

// ----------------------------------------------------------------------------

uint16_t
Rtc::getAsynchronousPrescaler()
{
    return (RTC->PRER & RTC_PRER_PREDIV_A_Msk) >> RTC_PRER_PREDIV_A_Pos;
}

// ----------------------------------------------------------------------------

uint16_t
Rtc::getSynchronousPrescaler()
{
    return (RTC->PRER & RTC_PRER_PREDIV_S_Msk) >> RTC_PRER_PREDIV_S_Pos;
}

}