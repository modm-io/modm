/*
 * Copyright (c) 2016, Sascha Schade
 * Copyright (c) 2016-2017, Fabian Greif
 * Copyright (c) 2016-2017, 2019, Niklas Hauser
 * Copyright (c) 2020, Hannes Ellinger
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#include "../device.hpp"

/**
 * This code should _only_ enable internal memories and nothing else.
 * Since this is the first code executed after a reset, you do not
 * have access to _any_ data stored in RAM, since it has not yet been
 * initialized.
 * In the worst case you won't even have access to the stack, if the
 * memory containing the stack is not physically enabled yet.
 * In that case, consider using inline assembly to manage stack access
 * manually, until the memory is enabled.
 */
void
__modm_initialize_platform(void)
{
    /* Enable SWO trace functionality. If ENABLE_SWO is not defined, SWO pin will be used as GPIO (see Product
       Specification to see which one). */
    #if defined (ENABLE_SWO)
        CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
        NRF_CLOCK->TRACECONFIG |= CLOCK_TRACECONFIG_TRACEMUX_Serial << CLOCK_TRACECONFIG_TRACEMUX_Pos;
        NRF_P1->PIN_CNF[0] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif

    /* Enable Trace functionality. If ENABLE_TRACE is not defined, TRACE pins will be used as GPIOs (see Product
       Specification to see which ones). */
    #if defined (ENABLE_TRACE)
        CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
        NRF_CLOCK->TRACECONFIG |= CLOCK_TRACECONFIG_TRACEMUX_Parallel << CLOCK_TRACECONFIG_TRACEMUX_Pos;
        NRF_P0->PIN_CNF[7]  = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
        NRF_P1->PIN_CNF[0]  = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
        NRF_P0->PIN_CNF[12] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
        NRF_P0->PIN_CNF[11] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
        NRF_P1->PIN_CNF[9]  = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif

//     /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
//        for your device located at https://infocenter.nordicsemi.com/index.jsp  */
//     if (nrf52_errata_36()){
//         NRF_CLOCK->EVENTS_DONE = 0;
//         NRF_CLOCK->EVENTS_CTTO = 0;
//         NRF_CLOCK->CTIV = 0;
//     }

//     /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
//        for your device located at https://infocenter.nordicsemi.com/index.jsp  */
//     if (nrf52_errata_66()){
//         NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
//         NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
//         NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
//         NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
//         NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
//         NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
//         NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
//         NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
//         NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
//         NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
//         NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
//         NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
//         NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
//         NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
//         NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
//         NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
//         NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
//     }

//     /* Workaround for Errata 98 "NFCT: Not able to communicate with the peer" found at the Errata document
//        for your device located at https://infocenter.nordicsemi.com/index.jsp  */
//     if (nrf52_errata_98()){
//         *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
//     }

//     /* Workaround for Errata 103 "CCM: Wrong reset value of CCM MAXPACKETSIZE" found at the Errata document
//        for your device located at https://infocenter.nordicsemi.com/index.jsp  */
//     if (nrf52_errata_103()){
//         NRF_CCM->MAXPACKETSIZE = 0xFBul;
//     }

//     /* Workaround for Errata 115 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
//        for your device located at https://infocenter.nordicsemi.com/index.jsp  */
//     if (nrf52_errata_115()){
//         *(volatile uint32_t *)0x40000EE4ul = (*(volatile uint32_t *)0x40000EE4ul & 0xFFFFFFF0ul) | (*(uint32_t *)0x10000258ul & 0x0000000Ful);
//     }

//     /* Workaround for Errata 120 "QSPI: Data read or written is corrupted" found at the Errata document
//        for your device located at https://infocenter.nordicsemi.com/index.jsp  */
//     if (nrf52_errata_120()){
//         *(volatile uint32_t *)0x40029640ul = 0x200ul;
//     }

//     /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
//        for your device located at https://infocenter.nordicsemi.com/index.jsp  */
//     if (nrf52_errata_136()){
//         if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
//             NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
//         }
//     }

    /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
     * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
     * operations are not used in your code. */
    #if (__FPU_USED == 1)
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
        __DSB();
        __ISB();
    #endif

    /* Configure NFCT pins as GPIOs if NFCT is not to be used in your code. If CONFIG_NFCT_PINS_AS_GPIOS is not defined,
       two GPIOs (see Product Specification to see which ones) will be reserved for NFC and will not be available as
       normal GPIOs. */
    #if defined (CONFIG_NFCT_PINS_AS_GPIOS)
        if ((NRF_UICR->NFCPINS & UICR_NFCPINS_PROTECT_Msk) == (UICR_NFCPINS_PROTECT_NFC << UICR_NFCPINS_PROTECT_Pos)){
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
            NRF_UICR->NFCPINS &= ~UICR_NFCPINS_PROTECT_Msk;
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
            NVIC_SystemReset();
        }
    #endif

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
            NRF_UICR->PSELRESET[0] = 18;
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
            NRF_UICR->PSELRESET[1] = 18;
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
            NVIC_SystemReset();
        }
    #endif
}
