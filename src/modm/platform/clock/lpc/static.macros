%#/*
%# * Copyright (c) 2013, Kevin Laeufer
%# * Copyright (c) 2014-2016, Niklas Hauser
%# * Copyright (c) 2017, Fabian Greif
%# *
%# * This file is part of the modm project.
%# *
%# * This Source Code Form is subject to the terms of the Mozilla Public
%# * License, v. 2.0. If a copy of the MPL was not distributed with this
%# * file, You can obtain one at http://mozilla.org/MPL/2.0/.
%# */
%#// ----------------------------------------------------------------------------


%% macro assertFrequency(name, frequency, type, value)
%%	if value != None and value|length > 0
%%		if type|lower == "min"
	static_assert({{ frequency }} >= {{ value }},
		"{{ frequency }} of {{ name }} needs to be higher or equal to {{ value }}");
%%		elif type|lower == "max"
	static_assert({{ frequency }} <= {{ value }},
		"{{ frequency }} of {{ name }} needs to be lower or equal to {{ value }}");
%%		endif
%%	endif
%% endmacro

%% macro source(s, type_id_namespace)

%%	if "fixedFrequency" in s and s.fixedFrequency|length > 0
template<int InputFrequency> class {{ s.name }};

template<>
class
{{ s.name }}<{{ s.fixedFrequency }}>
%%	else
template<int InputFrequency>
class
{{ s.name }}
%%	endif
{
private:
{{ assertFrequency("InputFrequency", "min", s.minFrequency, None) }}
{{ assertFrequency("InputFrequency", "max", s.maxFrequency, None) }}
public:
	static const ::{{type_id_namespace}}::TypeId::{{ s.name }} Id;

	static StartupError
	enable(const uint32_t waitCycles = 1500)
	{
%% if target["family"] == "lpc"
	%%	if s.fixedFrequency|length > 0
		if (!ClockControl::enable{{ s.name }}({{ s.fixedFrequency }}/1000, waitCycles))
	%% else
		if (!ClockControl::enable{{ s.name }}(InputFrequency/1000, waitCycles))
	%% endif
%% else
		if (!ClockControl::enable{{ s.name }}(waitCycles))
%% endif
			return StartupError::{{ s.name }};


%% if target["platform"] == "stm32" and target["family"] in ["f2", "f4"]
		ClockControl::setApb1Prescaler(ClockControl::Apb1Prescaler::Div4);
		ClockControl::setApb2Prescaler(ClockControl::Apb2Prescaler::Div2);
%% elif partname.startswith("stm32f100")
		ClockControl::setApb1Prescaler(ClockControl::Apb1Prescaler::Div1);
		ClockControl::setApb2Prescaler(ClockControl::Apb2Prescaler::Div1);
%% elif target["platform"] == "stm32" and target["family"] in ["f1", "f3"]
		ClockControl::setApb1Prescaler(ClockControl::Apb1Prescaler::Div2);
		ClockControl::setApb2Prescaler(ClockControl::Apb2Prescaler::Div1);
%% endif

		return StartupError::None;
	}

	static constexpr int
%% if "fixedFrequency" in s and s.fixedFrequency|length > 0
	outputFrequency = {{ s.fixedFrequency }};
%% else
	outputFrequency = InputFrequency;
%% endif
};
%% endmacro


%% macro pll(p,type_id_namespace)
%% if "frequencies" in p and p.frequencies|length > 0
%%		set template = ", " + p.frequencies|join(', ')
%%		set template_type = ", int " + p.frequencies|join(', int ')
%% else
%%		set template = ""
%%		set template_type = ""
%% endif

template<class Input, int OutputFrequency{{ template_type }}> class Pll;

%%	for src in p.sources
template<int InputFrequency, int OutputFrequency{{ template_type }}>
class
Pll<{{ src.name }}<InputFrequency>, OutputFrequency{{ template }}>
{
public:
	static const ::{{type_id_namespace}}::TypeId::{{ p.name }} Id;

	static StartupError
	enable(const uint32_t waitCycles = 1500)
	{
		StartupError err = StartupError::None;
		err = {{ src.name }}<InputFrequency>::enable(waitCycles);
		if (err != StartupError::None) return err;
		return PllSetup<InputFrequency,
				OutputFrequency{{ template }},
				ClockControl::PllSource::{{ src.name }}>::enable();
	}
	static constexpr int
	outputFrequency = OutputFrequency;
};
%%	endfor
%% endmacro

%% macro _subsink(sink, parent)
	%% set str = "static constexpr int "
	%% if "name" in sink and sink.name|length > 0
		%% set str =  str ~ sink.name ~ " = " ~ parent
		%% if sink.prescaler
			%% set str = str ~ " * " ~ sink.prescaler
		%% endif
	%% else
		%% set str = str ~ sink ~ " = " ~ parent
	%% endif
	{{ str ~ ";" }}
	%% if "name" in sink and "sinks" in sink and sink.name|length > 0 and sink.sinks|length > 0
		%% for subsink in sink.sinks
{{ _subsink(subsink, sink.name) }}
		%% endfor
	%% endif
%% endmacro

%% macro sink(s, type_id_namespace)

template<class Input> class {{ s.name }};

%%	for src in s.sources

%# check if source has input
%%	if "sources" in src and src.sources|length > 0
%%		if "frequencies" in src and src.frequencies|length > 0
%%			set template = "Input, OutputFrequency, " + src.frequencies|join(', ')
%%			set template_type = "class Input, int OutputFrequency, int " + src.frequencies|join(', int ')
%%		else
%%			set template = "Input, OutputFrequency"
%%			set template_type = "class Input, int OutputFrequency"
%%		endif
%%	else
%%		set template = "OutputFrequency"
%%		set template_type = "int OutputFrequency"
%%	endif

template<{{ template_type }}>
class
{{ s.name }}<{{ src.name }}<{{ template }}> >
{
private:
{{ assertFrequency(s.name, "OutputFrequency", "min", s.minFrequency) }}
{{ assertFrequency(s.name, "OutputFrequency", "max", s.maxFrequency) }}
public:
	/// TypeId to connect an Output to {{ s.name }}
	static const ::{{type_id_namespace}}::TypeId::{{ s.name }} Id;

	// Frequencies
	static constexpr int Frequency = OutputFrequency;
	%% for subsink in s.sinks
{{ _subsink(subsink, "Frequency") }}
	%% endfor

	static StartupError
	enable(const uint32_t waitCycles = 1500)
	{
		StartupError err =  {{ src.name }}<{{ template }}>::enable(waitCycles);
		if (err != StartupError::None) return err;
		ClockControl::setFlashLatency(OutputFrequency);
		if(ClockControl::enable{{ s.name }}(
				ClockControl::{{ s.name }}Source::{{ src.name }}, waitCycles))
			return StartupError::None;
		return StartupError::{{ src.name }};
	}
};
%%	endfor
%% endmacro

%% macro output(o, type_id_namespace)
class {{ o.name }}
{
public:
	static const ::{{type_id_namespace}}::TypeId::{{ o.name }} Id;

%% if o.divisions|length > 0
	enum class Division
	{
%%	for d in o.divisions
		By{{ d }} = {{ d }},
%%	endfor
	};

	static xpcc_always_inline void
	setDivision(Division)
	{
		//ClockControl::enable{{ o.name }}(static_cast<int>(d));
	}
%% endif
	// Connect Functions
%% for src in o.sources
	static xpcc_always_inline void
%% if target["platform"] == "stm32" and target["family"] in ["f2", "f4"]
	connect(::{{type_id_namespace}}::TypeId::{{ src.name }} /* t */, uint8_t div = 1)
	{
		ClockControl::enable{{ o.name }}(ClockControl::{{ o.name }}Source::{{ src.name }}, div);
	}
%% else
	connect(::{{type_id_namespace}}::TypeId::{{ src.name }} /* t */)
	{
		ClockControl::enable{{ o.name }}(ClockControl::{{ o.name }}Source::{{ src.name }});
	}
%% endif
%% endfor
};
%% endmacro
