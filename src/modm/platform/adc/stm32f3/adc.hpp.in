/*
 * Copyright (c) 2013-2014, Kevin Läufer
 * Copyright (c) 2014, 2016-2018, Niklas Hauser
 * Copyright (c) 2017, Sascha Schade
 * Copyright (c) 2020, Raphael Lehmann
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32F3_ADC{{ id }}_HPP
#define MODM_STM32F3_ADC{{ id }}_HPP

#include <stdint.h>
#include <nonstd/span.hpp>
#include <array>
#include "../device.hpp"
#include <modm/architecture/interface/register.hpp>
#include <modm/platform/gpio/connector.hpp>

namespace modm
{
namespace platform
{
/**
 * Analog/Digital-Converter module (ADC{{ id }}).
 *
 * The 12-bit ADC is a successive approximation analog-to-digital
 * converter. It has up to 19 multiplexed channels allowing it measure
 * signals from 16 external and three internal sources.
 * The result of the ADC is stored in a left-aligned or right-aligned
 * 16-bit data register.
 *
 * This API is designed for the internal ADCs of STM32F30X/STM32F31X
 *
 * \author	Kevin Laeufer
 * \author	Sascha Schade (strongly-typed)
 * \ingroup	modm_platform_adc modm_platform_adc_{{id}}
 */
class Adc{{ id }}
{
public:
	/// Channels, which can be used with this ADC.
	enum class Channel : uint8_t	// TODO: What is the best type?
	{
%% for channel in channels
		Channel{{ channel }} = {{ channel }},
%% endfor
%#
%% if id == 1
%% if target["family"] in ["f3"]
		Opamp1    = 15,
		VTS       = 16,
		BatDiv2   = 17,
		InternalReference = 18,
%% elif target["family"] in ["l4"]
		Temperature = 17,
		BatDiv3     = 18,
%% elif target["family"] in ["g4"]
		Opamp1 = 13,
		Temperature = 16,
		BatDiv3     = 17,
		InternalReference = 18,
%% endif
%% elif id == 2
%% if target["family"] in ["f3"]
		Opamp2 = 17,
		InternalReference = 18,
%% elif target["family"] in ["l4"]
		Dac1 = 17,
		Dac2 = 18,
%% elif target["family"] in ["g4"]
		Opamp2 = 16,
		Opamp3 = 18,
%% endif
%% elif id == 3
%% if target["family"] in ["f3"]
		Vss    =  4,	// ADC3_IN4 not bonded and connected to VSS
		Opamp3 = 17,
		InternalReference = 18,
%% elif target["family"] in ["l4"]
		Dac1 = 14,
		Dac2 = 15,
		Vss  = 16,
		Temperature = 17,
		BatDiv3 = 18,
%% elif target["family"] in ["g4"]
		Opamp3 = 13,
		BatDiv3 = 17,
		InternalReference  = 18,
%% endif
%% elif id == 4
%% if target["family"] in ["f3"]
		Opamp3 = 17,
%% elif target["family"] in ["l4", "g4"]
		Opamp6 = 17,
%% endif
		InternalReference = 18,
%% elif id == 5
%% if target["family"] in ["g4"]
		Opamp5 = 3,
		Temperature = 4,
		Opamp4 = 5,
		BatDiv3 = 17,
		InternalReference = 18,
%% endif
%% endif
	};

	enum class ClockMode : uint32_t
	{
		DoNotChange = 0xff,// if you do not want to change the clock mode
		Asynchronous = 0,	// clocked by ADC_CK12 / ADC_CK34 / ADC123_CK
		// In synchronous mode ADC is clocked by the AHB clock (stm32f3) or
		// by HCLK (stm32l4)
		SynchronousPrescaler1 = {{ adc_ccr }}_CKMODE_0,
		SynchronousPrescaler2 = {{ adc_ccr }}_CKMODE_1,
		SynchronousPrescaler4 = {{ adc_ccr }}_CKMODE_1 | {{ adc_ccr }}_CKMODE_0,
	};

%% if clock_mux
	// ADCs clock source selection
	enum class ClockSource : uint32_t
	{
		NoClock = 0, // No clock selected.
%% if target["family"] in ["g4"]
%% if id in [1, 2]
		Pll = RCC_CCIPR_ADC12SEL_0, // PLL “P” clock selected as ADC clock
		SystemClock = RCC_CCIPR_ADC12SEL_1 , // System clock selected as ADCs clock
%% elif id in [3, 4, 5]
		Pll = RCC_CCIPR_ADC345SEL_0, // PLL “P” clock selected as ADC clock
		SystemClock = RCC_CCIPR_ADC345SEL_1 , // System clock selected as ADCs clock
%% endif
%% else
		PllSai1 = RCC_CCIPR_ADCSEL_0, // PLLSAI1 "R" clock (PLLADC1CLK) selected as ADCs clock
		PllSai2 = RCC_CCIPR_ADCSEL_1, // PLLSAI2 "R" clock (PLLADC2CLK) selected as ADCs clock
		SystemClock = RCC_CCIPR_ADCSEL_1 | RCC_CCIPR_ADCSEL_0, // System clock selected as ADCs clock
%% endif
	};
%% endif

	// Prescaler of the Asynchronous ADC clock
	enum class Prescaler : uint32_t
	{
		Disabled 			= 0,
%% if target["family"] in ["f3"]
		Div1 				= RCC_CFGR2_{{ adc_pre }}_DIV1,
		Div2 				= RCC_CFGR2_{{ adc_pre }}_DIV2,
		Div4 				= RCC_CFGR2_{{ adc_pre }}_DIV4,
		Div6 				= RCC_CFGR2_{{ adc_pre }}_DIV6,
		Div8 				= RCC_CFGR2_{{ adc_pre }}_DIV8,
		Div10 				= RCC_CFGR2_{{ adc_pre }}_DIV10,
		Div12 				= RCC_CFGR2_{{ adc_pre }}_DIV12,
		Div16 				= RCC_CFGR2_{{ adc_pre }}_DIV16,
		Div32 				= RCC_CFGR2_{{ adc_pre }}_DIV32,
		Div64 				= RCC_CFGR2_{{ adc_pre }}_DIV64,
		Div128 				= RCC_CFGR2_{{ adc_pre }}_DIV128,
		Div256 				= RCC_CFGR2_{{ adc_pre }}_DIV256,
		Div256AllBits 		= RCC_CFGR2_{{ adc_pre }},	// for bit clear
%% elif target["family"] in ["l4", "g4"]
		Div1 				= 0,
		Div2 				= ADC_CCR_PRESC_0,
		Div4 				= ADC_CCR_PRESC_1,
		Div6 				= ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0,
		Div8 				= ADC_CCR_PRESC_2,
		Div10 				= ADC_CCR_PRESC_2 | ADC_CCR_PRESC_0,
		Div12 				= ADC_CCR_PRESC_2 | ADC_CCR_PRESC_1,
		Div16 				= ADC_CCR_PRESC_2 | ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0,
		Div32 				= ADC_CCR_PRESC_3,
		Div64 				= ADC_CCR_PRESC_3 | ADC_CCR_PRESC_0,
		Div128 				= ADC_CCR_PRESC_3 | ADC_CCR_PRESC_1,
		Div256 				= ADC_CCR_PRESC_3 | ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0,
		Div256AllBits 		= ADC_CCR_PRESC_3 | ADC_CCR_PRESC_2 | ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0,	// for bit clear
%% endif
	};

%% if target["family"] in ["l4", "g4"]
	enum class SampleTime : uint8_t	// TODO: What is the best type?
	{
		Cycles2 	= 0b000,	//!   1.5 ADC clock cycles
		Cycles7 	= 0b001,	//!   6.5 ADC clock cycles
		Cycles13 	= 0b010,	//!  12.5 ADC clock cycles
		Cycles25	= 0b011,	//!  24.5 ADC clock cycles
		Cycles48 	= 0b100,	//!  47.5 ADC clock cycles
		Cycles93 	= 0b101,	//!  92.5 ADC clock cycles
		Cycles248 	= 0b110,	//! 247.5 ADC clock cycles
		Cycles641 	= 0b111,	//! 640.5 ADC clock cycles
	};
%% else
	enum class SampleTime : uint8_t	// TODO: What is the best type?
	{
		Cycles2 	= 0b000,	//!   1.5 ADC clock cycles
		Cycles3 	= 0b001,	//!   2.5 ADC clock cycles
		Cycles5 	= 0b010,	//!   4.5 ADC clock cycles
		Cycles8 	= 0b011,	//!   7.5 ADC clock cycles
		Cycles20 	= 0b100,	//!  19.5 ADC clock cycles
		Cycles62 	= 0b101,	//!  61.5 ADC clock cycles
		Cycles182 	= 0b110,	//! 181.5 ADC clock cycles
		Cycles602 	= 0b111,	//! 601.5 ADC clock cycles
	};
%% endif
	enum class CalibrationMode : uint32_t
	{
		SingleEndedInputsMode = 0,
		DifferntialInputsMode = ADC_CR_ADCALDIF,
		DoNotCalibrate = 0xff,	// if you want to avoid calibration
	};

	enum class VoltageRegulatorState : uint32_t
	{
%% if target["family"] in ["l4", "g4"]
		Enabled 		= ADC_CR_ADVREGEN,
%% elif target["family"] in ["f3"]
		// Intermediate state is needed to move from enabled to disabled
		// state and vice versa
		Intermediate 	= 0,
		Enabled 		= ADC_CR_ADVREGEN_0,
		Disables		= ADC_CR_ADVREGEN_1,
%% endif
	};

	enum class TriggerMode : uint8_t
	{
		Disabled		= 0b00,
		SoftwareTrigger	= Disabled,
		RisingEdge		= 0b01,
		FallingEdge		= 0b10,
		BothEdges		= 0b11,
	};

	enum class TriggerSourceRegular : uint8_t
	{
%% if target["family"] in ["g4"]
%% if id in [1, 2]
		Tim1Cc1			= 0b00000,
		Tim1Cc2			= 0b00001,
		Tim1Cc3			= 0b00010,
		Tim2Cc2			= 0b00011,
		Tim3Trgo		= 0b00100,
		Tim4Cc4			= 0b00101,
		ExtiLine11		= 0b00110,
		Tim8Trgo		= 0b00111,
		Tim8Trgo2		= 0b01000,
		Tim1Trgo		= 0b01001,
		Tim1Trgo2		= 0b01010,
		Tim2Trgo		= 0b01011,
		Tim4Trgo		= 0b01100,
		Tim6Trgo		= 0b01101,
		Tim15Trgo		= 0b01110,
		Tim3Cc4			= 0b01111,
		Tim20Trgo		= 0b10000,
		Tim20Trgo2		= 0b10001,
		Tim20Cc1		= 0b10010,
		Tim20Cc2		= 0b10011,
		Tim20Cc3		= 0b10100,
		HrtimAdcTrg1	= 0b10101,
		HrtimAdcTrg3	= 0b10110,
		HrtimAdcTrg5	= 0b10111,
		HrtimAdcTrg6	= 0b11000,
		HrtimAdcTrg7	= 0b11001,
		HrtimAdcTrg8	= 0b11010,
		HrtimAdcTrg9	= 0b11011,
		HrtimAdcTrg10	= 0b11100,
		Lptimout		= 0b11101,
		Tim7Trgo		= 0b11110,
		//Reserved		= 0b11111,
%% elif id in [3, 4, 5]
		Tim3Cc1			= 0b00000,
		Tim2Cc3			= 0b00001,
		Tim1Cc3			= 0b00010,
		Tim8Cc1			= 0b00011,
		Tim3Trgo		= 0b00100,
		ExtiLine2		= 0b00101,
		Tim4Cc1			= 0b00110,
		Tim8Trgo		= 0b00111,
		Tim8Trgo2		= 0b01000,
		Tim1Trgo		= 0b01001,
		Tim1Trgo2		= 0b01010,
		Tim2Trgo		= 0b01011,
		Tim4Trgo		= 0b01100,
		Tim6Trgo		= 0b01101,
		Tim15Trgo		= 0b01110,
		Tim2Cc1			= 0b01111,
		Tim20Trgo		= 0b10000,
		Tim20Trgo2		= 0b10001,
		Tim20Cc1		= 0b10010,
		HrtimAdcTrg2	= 0b10011,
		HrtimAdcTrg4	= 0b10100,
		HrtimAdcTrg1	= 0b10101,
		HrtimAdcTrg3	= 0b10110,
		HrtimAdcTrg5	= 0b10111,
		HrtimAdcTrg6	= 0b11000,
		HrtimAdcTrg7	= 0b11001,
		HrtimAdcTrg8	= 0b11010,
		HrtimAdcTrg9	= 0b11011,
		HrtimAdcTrg10	= 0b11100,
		Lptimout		= 0b11101,
		Tim7Trgo		= 0b11110,
		//Reserved		= 0b11111,
%% endif
%% else
		ExtTrigger0		= 0b0,
		ExtTrigger1		= 0b1,
		ExtTrigger2		= 0b10,
		ExtTrigger3		= 0b11,
		ExtTrigger4		= 0b100,
		ExtTrigger5		= 0b101,
		ExtTrigger6		= 0b110,
		ExtTrigger7		= 0b111,
		ExtTrigger8		= 0b1000,
		ExtTrigger9		= 0b1001,
		ExtTrigger10	= 0b1010,
		ExtTrigger11	= 0b1011,
		ExtTrigger12	= 0b1100,
		ExtTrigger13	= 0b1101,
		ExtTrigger14	= 0b1110,
		ExtTrigger15	= 0b1111,
		ExtTrigger16	= 0b10000,
		ExtTrigger17	= 0b10001,
		ExtTrigger18	= 0b10010,
		ExtTrigger19	= 0b10011,
		ExtTrigger20	= 0b10100,
		ExtTrigger21	= 0b10101,
		ExtTrigger22	= 0b10110,
		ExtTrigger23	= 0b10111,
		ExtTrigger24	= 0b11000,
		ExtTrigger25	= 0b11001,
		ExtTrigger26	= 0b11010,
		ExtTrigger27	= 0b11011,
		ExtTrigger28	= 0b11100,
		ExtTrigger29	= 0b11101,
		ExtTrigger30	= 0b11110,
		ExtTrigger31	= 0b11111,
%% endif
	};

	enum class TriggerSourceInjected : uint8_t
	{
%% if target["family"] in ["g4"]
%% if id in [1, 2]
		Tim1Trgo		= 0b00000,
		Tim1Cc4			= 0b00001,
		Tim2Trgo		= 0b00010,
		Tim2Cc1			= 0b00011,
		Tim3Cc4			= 0b00100,
		Tim4Trgo		= 0b00101,
		ExtiLine15		= 0b00110,
		Tim8Cc4			= 0b00111,
		Tim1Trgo2		= 0b01000,
		Tim8Trgo		= 0b01001,
		Tim8Trgo2		= 0b01010,
		Tim3Cc3			= 0b01011,
		Tim3Trgo		= 0b01100,
		Tim3Cc1			= 0b01101,
		Tim6Trgo		= 0b01110,
		Tim15Trgo		= 0b01111,
		Tim20Trgo		= 0b10000,
		Tim20Trgo2		= 0b10001,
		Tim20Cc4		= 0b10010,
		HrtimAdcTrg2	= 0b10011,
		HrtimAdcTrg4	= 0b10100,
		HrtimAdcTrg5	= 0b10101,
		HrtimAdcTrg6	= 0b10110,
		HrtimAdcTrg7	= 0b10111,
		HrtimAdcTrg8	= 0b11000,
		HrtimAdcTrg9	= 0b11001,
		HrtimAdcTrg10	= 0b11010,
		Tim16Cc1		= 0b11011,
		//Reserved		= 0b11100,
		Lptimout		= 0b11101,
		Tim7Trgo		= 0b11110,
		//Reserved		= 0b11111,
%% elif id in [3, 4, 5]
		Tim1Trgo		= 0b00000,
		Tim1Cc4			= 0b00001,
		Tim2Trgo		= 0b00010,
		Tim8Cc2			= 0b00011,
		Tim4Cc3			= 0b00100,
		Tim4Trgo		= 0b00101,
		Tim4Cc4			= 0b00110,
		Tim8Cc4			= 0b00111,
		Tim1Trgo2		= 0b01000,
		Tim8Trgo		= 0b01001,
		Tim8Trgo2		= 0b01010,
		Tim1Cc3			= 0b01011,
		Tim3Trgo		= 0b01100,
		ExtiLine3		= 0b01101,
		Tim6Trgo		= 0b01110,
		Tim15Trgo		= 0b01111,
		Tim20Trgo		= 0b10000,
		Tim20Trgo2		= 0b10001,
		Tim20Cc2		= 0b10010,
		HrtimAdcTrg2	= 0b10011,
		HrtimAdcTrg4	= 0b10100,
		HrtimAdcTrg5	= 0b10101,
		HrtimAdcTrg6	= 0b10110,
		HrtimAdcTrg7	= 0b10111,
		HrtimAdcTrg8	= 0b11000,
		HrtimAdcTrg9	= 0b11001,
		HrtimAdcTrg10	= 0b11010,
		HrtimAdcTrg1	= 0b11011,
		HrtimAdcTrg3	= 0b11100,
		Lptimout		= 0b11101,
		Tim7Trgo		= 0b11110,
		//Reserved		= 0b11111,
%% endif
%% else
		ExtTrigger0		= 0b0,
		ExtTrigger1		= 0b1,
		ExtTrigger2		= 0b10,
		ExtTrigger3		= 0b11,
		ExtTrigger4		= 0b100,
		ExtTrigger5		= 0b101,
		ExtTrigger6		= 0b110,
		ExtTrigger7		= 0b111,
		ExtTrigger8		= 0b1000,
		ExtTrigger9		= 0b1001,
		ExtTrigger10	= 0b1010,
		ExtTrigger11	= 0b1011,
		ExtTrigger12	= 0b1100,
		ExtTrigger13	= 0b1101,
		ExtTrigger14	= 0b1110,
		ExtTrigger15	= 0b1111,
		ExtTrigger16	= 0b10000,
		ExtTrigger17	= 0b10001,
		ExtTrigger18	= 0b10010,
		ExtTrigger19	= 0b10011,
		ExtTrigger20	= 0b10100,
		ExtTrigger21	= 0b10101,
		ExtTrigger22	= 0b10110,
		ExtTrigger23	= 0b10111,
		ExtTrigger24	= 0b11000,
		ExtTrigger25	= 0b11001,
		ExtTrigger26	= 0b11010,
		ExtTrigger27	= 0b11011,
		ExtTrigger28	= 0b11100,
		ExtTrigger29	= 0b11101,
		ExtTrigger30	= 0b11110,
		ExtTrigger31	= 0b11111,
%% endif
	};

	enum class Interrupt : uint32_t
	{
		Ready 								= ADC_IER_ADRDYIE,
		EndOfSampling 						= ADC_IER_EOSMPIE,
		EndOfRegularConversion 				= ADC_IER_EOCIE,
		EndOfRegularSequenceOfConversions 	= ADC_IER_EOSIE,
		Overrun 							= ADC_IER_OVRIE,
		EndOfInjectedConversion 			= ADC_IER_JEOCIE,
		EndOfInjectedSequenceOfConversions 	= ADC_IER_JEOSIE,
		AnalogWatchdog1 					= ADC_IER_AWD1IE,
		AnalogWatchdog2 					= ADC_IER_AWD2IE,
		AnalogWatchdog3 					= ADC_IER_AWD3IE,
		InjectedContextQueueOverflow 		= ADC_IER_JQOVFIE,
	};
	MODM_FLAGS32(Interrupt);

	enum class InterruptFlag : uint32_t
	{
		Ready 								= ADC_ISR_ADRDY,
		EndOfSampling 						= ADC_ISR_EOSMP,
		EndOfRegularConversion 				= ADC_ISR_EOC,
		EndOfRegularSequenceOfConversions 	= ADC_ISR_EOS,
		Overrun 							= ADC_ISR_OVR,
		EndOfInjectedConversion 			= ADC_ISR_JEOC,
		EndOfInjectedSequenceOfConversions 	= ADC_ISR_JEOS,
		AnalogWatchdog1 					= ADC_ISR_AWD1,
		AnalogWatchdog2 					= ADC_ISR_AWD2,
		AnalogWatchdog3 					= ADC_ISR_AWD3,
		InjectedContextQueueOverflow 		= ADC_ISR_JQOVF,
	};
	MODM_FLAGS32(InterruptFlag);

	static constexpr uint8_t maxSequenceLength = 16;
	static constexpr uint8_t maxInjectedSequenceLength = 4;

private:
	static inline bool
	setSequenceChannel(const int index, const Channel channel);

	static uint32_t sqr1;
	static uint32_t sqr2;
	static uint32_t sqr3;
	static uint32_t sqr4;

public:
	template< template<Peripheral _> class... Signals >
	static void
	connect()
	{
		using Connector = GpioConnector<Peripheral::Adc{{ id }}, Signals...>;
		Connector::connect();
	}

	/**
	 * Initialize and enable the A/D converter.
	 *
	 * Enables the ADC clock and switches on the ADC. The ADC clock
	 * prescaler will be set as well.
	 *
	 * The ADC can be clocked
	 *
	 * @param clk
	 * 		Clock Mode for ADC1/ADC2 or ADC3/ADC4.
	 * 		Set to ClockMode::DoNotChange or leave blank if you
	 * 		want to leave this setting untouched.
	 *
	 * @param pre
	 * 		The prescaler for the asynchronous ADC clock.
	 * 		This parameter is only taken into account
	 * 		if clk == ClockMode::Asynchronous.
	 */
	static inline void
	initialize(	const ClockMode clk = ClockMode::DoNotChange,
%% if clock_mux
				const ClockSource clk_src = ClockSource::SystemClock,
%% endif
				const Prescaler pre = Prescaler::Disabled,
				const CalibrationMode cal = CalibrationMode::DoNotCalibrate,
				const bool blocking = true);

	static inline void
	disable(const bool blocking = true);

	/**
	 * Select the frequency of the clock to the ADC. The clock is common
	 * for ADC1/ADC2 and ADC3/ADC4.
	 *
	 * @pre The PLL must be running.
	 *
	 * @param prescaler
	 * 		The prescaler specifies by which factor the system clock
	 * 		will be divided.
	 */
	static inline void
	setPrescaler(const Prescaler pre);

	/**
	 * Returns true if the ADRDY bit of the ISR is set
	 **/
	static inline bool
	isReady();

	static inline void
	calibrate(const CalibrationMode mode, const bool blocking = true);

	/**
	 * Change the presentation of the ADC conversion result.
	 *
	 * @param enable
	 * 		Set to \c true to left adjust the result.
	 *		Otherwise, the result is right adjusted.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 		initialize()
	 */
	static inline void
	setLeftAdjustResult(const bool enable);

	/**
	 * Analog channel selection.
	 *
	 * This not for scan mode. The number of channels will be set to 1,
	 * the channel selected and the corresponding pin will be set to
	 * analog input.
	 * If the the channel is modified during a conversion, the current
	 * conversion is reset and a new start pulse is sent to the ADC to
	 * convert the new chosen channnel / group of channels.
	 *
	 *
	 * @param channel		The channel which shall be read.
	 * @param sampleTime	The sample time to sample the input voltage.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 		initialize()
	 */
	static inline bool
	setChannel(const Channel channel,
			const SampleTime sampleTime=static_cast<SampleTime>(0b000))
	{
		return setSequenceChannel(0, channel)
			&& setChannelSampleTime(channel, sampleTime);
	}

	/**
	 * Analog channel selection.
	 *
	 * Up to @see maxSequenceLength channels con be configured to be read
	 * in a sequence.
	 *
	 * @param channels		List (std::span) of up to @see maxSequenceLength
							channels which shall be read.
	 * @param sampleTime	The sample time to sample the input voltage.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 		initialize()
	 */
	static inline bool
	setChannel(const nonstd::span<const Channel> channels);

	/**
	 * Analog injected channel selection.
	 *
	 * @see setChannel()
	 *
	 * @param channel		The channel which shall be read.
	 * @param sampleTime	The sample time to sample the input voltage.
	 */
	static inline bool
	setInjectedChannel(const Channel channel,
			const SampleTime sampleTime=static_cast<SampleTime>(0b000))
	{
		return setInjectedChannel(std::array <Channel, 1>{ channel, })
			&& setChannelSampleTime(channel, sampleTime);
	}

	/**
	 * Analog injected channel selection.
	 *
	 * Up to @see maxInjectedSequenceLength channels con be configured to
	 * be read in a sequence.
	 *
	 * @param channels		List (std::span) of up to @see
							maxInjectedSequenceLength channels which shall
							be read.
	 * @param sampleTime	The sample time to sample the input voltage.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 		initialize()
	 */
	static inline bool
	setInjectedChannel(const nonstd::span<const Channel> channels);

	/// Setting the channel by Gpio pin
	template< class Gpio >
	static inline bool
	setPinChannel(SampleTime sampleTime = static_cast<SampleTime>(0b000))
	{
		return setChannel(getPinChannel<Gpio>(), sampleTime);
	}

	/// Setting injected channel by Gpio pin
	template< class Gpio >
	static inline bool
	setInjectedPinChannel(SampleTime sampleTime = static_cast<SampleTime>(0b000))
	{
		return setInjectedChannel(getPinChannel<Gpio>(), sampleTime);
	}

	/// Get the channel for a Pin
	template< class Gpio >
	static inline constexpr Channel
	getPinChannel()
	{
		constexpr int8_t channel{Gpio::template AdcChannel<Peripheral::Adc{{ id }}>};
		static_assert(channel >= 0, "Adc{{id}} does not have a channel for this pin!");
		return Channel(channel);
	}

	static inline bool
	setChannelSampleTime(const Channel channel, const SampleTime sampleTime);

	/**
	 * Enables free running mode
	 *
	 * The ADC will continously start conversions and provide the most
	 * recent result in the ADC register.
	 *
	 * @pre The ADC clock must be started and the ADC switched on with
	 * 		initialize()
	 */
	static inline void
	setFreeRunningMode(const bool enable);

	/**
	 * Enables the trigger for a regular conversion sequence.
	 *
	 * @param mode		Selects the trigger mode or disables the trigger
	 * @param source	Selects one of the (up to 32) trigger sources
	 *
	 * @pre No ADC conversion must be ongoing when changing the
	 *      trigger configuration.
	 */
	static inline void
	setTrigger(const TriggerMode mode, const TriggerSourceRegular source);

	/**
	 * Enables the trigger for a injected conversion sequence.
	 *
	 * @param mode		Selects the trigger mode or disables the trigger
	 * @param source	Selects one of the (up to 32) trigger sources
	 *
	 * @pre No ADC conversion must be ongoing when changing the
	 *      trigger configuration.
	 */
	static inline void
	setInjectedTrigger(const TriggerMode mode, const TriggerSourceInjected source);

	/**
	 * Start a new conversion or continuous conversions.
	 *
	 * @pre A ADC channel must be selected with setChannel().
	 *
	 * @post The result can be fetched with getValue()
	 *
	 * TODO: is there any limitation to when is can be called??
	 */
	static inline void
	startConversion();

	/**
	 * Start a new injected conversion or continuous conversions.
	 *
	 * @pre A ADC channel must be selected with setChannel().
	 *
	 * @post The result can be fetched with getValue()
	 */
	static inline void
	startInjectedConversion();

	/**
	 * @return If the conversion is finished.
	 * @pre A conversion should have been stared with startConversion()
	 */
	static inline bool
	isConversionFinished();

	/**
	 * @return If the injected conversion is finished.
	 * @pre A injected conversion should have been stared
	 *   with startInjectedConversion()
	 */
	//static inline bool
	//isInjectedConversionFinished();

	/**
	 * @return The most recent 16bit result of the ADC conversion.
	 * @pre A conversion should have been stared with startConversion()
	 *
	 * To have a blocking GET you might do it this way:
	 * @code
		while(!isConversionFinished())
		{
			// Waiting for conversion
		}
		@endcode
	 */
	static inline uint16_t
	getValue()
	{
		return ADC{{ id }}->DR;
	}

	/**
	 * @return The most recent 16bit result of the injected conversion
	 * at the index of the sequence.
	 * @pre A injected conversion should have been stared
	 * with startInjectedConversion()
	 */
	static inline uint16_t
	getInjectedValue(uint8_t index);

	/**
	 * @return The most recent 16bit result of the injected conversion
	 * at the index of the sequence.
	 * @pre A injected conversion should have been stared
	 * with startInjectedConversion()
	 */
	template<uint8_t index>
	static inline uint16_t
	getInjectedValue();

	static inline void
	enableInterruptVector(const uint32_t priority, const bool enable = true);

	static inline void
	enableInterrupt(const Interrupt_t interrupt);

	static inline void
	disableInterrupt(const Interrupt_t interrupt);

	static inline InterruptFlag_t
	getInterruptFlags();

	static inline void
	acknowledgeInterruptFlag(const InterruptFlag_t flags);
};

}

}

#include "adc_{{ id }}_impl.hpp"

#endif	// MODM_STM32F3_ADC{{ id }}_HPP
