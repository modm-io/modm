/*
 * Copyright (c) 2013-2014, Kevin LÃ¤ufer
 * Copyright (c) 2014, Sascha Schade
 * Copyright (c) 2014, 2016-2017, Niklas Hauser
 * Copyright (c) 2020, Raphael Lehmann
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32F3_ADC{{ id }}_HPP
#	error 	"Don't include this file directly, use 'adc_{{ id }}.hpp' instead!"
#endif

#include <modm/architecture/interface/delay.hpp>	// modm::delayMicroseconds
#include <modm/platform/clock/rcc.hpp>
#include <modm/math/algorithm/enumerate.hpp>
#include <modm/math/algorithm/prescaler.hpp>

template< class SystemClock
          , modm::frequency_t frequency
          , modm::percent_t tolerance
          , modm::platform::Adc{{ id }}::ClockMode clk
          , modm::platform::Adc{{ id }}::ClockSource clk_src
		  >
void
modm::platform::Adc{{ id }}::initialize(bool blocking)
//		const Prescaler pre,
//		const CalibrationMode cal, const bool blocking)
{
	uint32_t tmp = 0;

	// enable clock
%% if target["family"] in ["f3", "g4"]
	RCC->{{ ahb }}ENR |= RCC_{{ ahb }}ENR_ADC{{ id_common }}EN;
%% elif target["family"] in ["l4"]
	Rcc::enable<Peripheral::Adc1>();
%% endif

%% if clock_mux
	// select clock source
	RCC->CCIPR = (RCC->CCIPR & ~ClockSourceMsk) | static_cast<uint32_t>(clk_src);
%% endif

%% if target["family"] in ["l4", "g4"]
	// Disable deep power down
	ADC{{ id }}->CR &= ~ADC_CR_DEEPPWD;
%% endif

	// reset ADC
	// FIXME: not a good idea since you can only reset both
	// ADC1/ADC2 or ADC3/ADC4 at once ....

	// set ADC "analog" clock source
	if (clk != ClockMode::DoNotChange) {
		if (clk == ClockMode::Asynchronous) {
			// FIXME
			// compute and set prescaler
		}
		ADC{{ id_common_u }}->CCR = (ADC{{ id_common_u }}->CCR & ~{{ adc_ccr }}_CKMODE_Msk) | static_cast<uint32_t>(clk);
	}

	// enable regulator
	ADC{{ id }}->CR &= ~ADC_CR_ADVREGEN;
	ADC{{ id }}->CR |= static_cast<uint32_t>(VoltageRegulatorState::Enabled);
	modm::delay_us(10);	// FIXME: this is ugly -> find better solution

	acknowledgeInterruptFlags(InterruptFlag::Ready);

	ADC{{ id }}->CR |= ADC_CR_ADEN;
	if (blocking) {
		// ADEN can only be set 4 ADC clock cycles after ADC_CR_ADCAL gets
		// cleared. Setting it in a loop ensures the flag gets set for ADC
		// clocks slower than the CPU clock.
		while (not isReady()) {
			ADC{{ id }}->CR |= ADC_CR_ADEN;
		}
		acknowledgeInterruptFlags(InterruptFlag::Ready);
	}
}

void
modm::platform::Adc{{ id }}::disable(const bool blocking)
{
	ADC{{ id }}->CR |= ADC_CR_ADDIS;
	if (blocking) {
		// wait for ADC_CR_ADDIS to be cleared by hw
		while(ADC{{ id }}->CR & ADC_CR_ADDIS);
	}
	// disable clock
%% if target["family"] in ["f3", "g4"]
	RCC->{{ ahb }}ENR &= ~RCC_{{ ahb }}ENR_ADC{{ id_common }}EN;
%% elif target["family"] in ["l4"]
	Rcc::disable<Peripheral::Adc1>();
%% endif
}

void
modm::platform::Adc{{ id }}::setPrescaler(const Prescaler pre)
{
	uint32_t tmp;
%% if target["family"] in ["f3"]
	tmp  = RCC->CFGR2;
	tmp &= ~static_cast<uint32_t>(Prescaler::Div256AllBits);
	tmp |=  static_cast<uint32_t>(pre);
	RCC->CFGR2 = tmp;
%% elif target["family"] in ["l4", "g4"]
	tmp  = ADC{{ id_common_u }}->CCR;
	tmp &= ~static_cast<uint32_t>(Prescaler::Div256AllBits);
	tmp |=  static_cast<uint32_t>(pre);
	ADC{{ id_common_u }}->CCR = tmp;
%% endif
}

bool
modm::platform::Adc{{ id }}::isReady()
{
	return static_cast<bool>(getInterruptFlags() & InterruptFlag::Ready);
}

void
modm::platform::Adc{{ id }}::calibrate(const CalibrationMode mode,
									const bool blocking)
{
	if (mode != CalibrationMode::DoNotCalibrate) {
		ADC{{ id }}->CR |= ADC_CR_ADCAL |
										static_cast<uint32_t>(mode);
		if(blocking) {
			// wait for ADC_CR_ADCAL to be cleared by hw
			while(ADC{{ id }}->CR & ADC_CR_ADCAL);
		}
	}
}

void
modm::platform::Adc{{ id }}::setLeftAdjustResult(const bool enable)
{
	if (enable) {
		ADC{{ id }}->CFGR |= ADC_CFGR_ALIGN;
	}
	else {
		ADC{{ id }}->CFGR &= ~ADC_CFGR_ALIGN;
	}
}

inline bool
modm::platform::Adc{{ id }}::setChannel(const Channel channel, const SampleTime sampleTime)
{
	sqr1 = 0;
	setSequenceChannel(0, channel);
	setChannelSampleTime(channel, sampleTime);

	// Write SQRx registers
	ADC{{ id }}->SQR1 = sqr1;

	return true;
}

inline bool
modm::platform::Adc{{ id }}::setChannel(const std::span<const Channel> channels)
{
	if(channels.size() >= maxSequenceLength) {
		return false;
	}

	// Clear temporary variables
	sqr1 = 0;
	sqr2 = 0;
	sqr3 = 0;
	sqr4 = 0;

	for (auto [i, channel] : enumerate(channels))
	{
		if(!setSequenceChannel(i, channel)) {
			return false;
		}
	}

	sqr1 |= (channels.size() - 1);

	// Write SQRx registers
	ADC{{ id }}->SQR1 = sqr1;
	ADC{{ id }}->SQR2 = sqr2;
	ADC{{ id }}->SQR3 = sqr3;
	ADC{{ id }}->SQR4 = sqr4;

	return true;
}

bool
modm::platform::Adc{{ id }}::setInjectedChannel(const std::span<const Channel> channels)
{
	if(channels.size() >= maxInjectedSequenceLength) {
		return false;
	}
	// clear JSQR register except for JEXTEN and JEXTSEL bits
	ADC{{ id }}->JSQR &= ADC_JSQR_JEXTEN_Msk | ADC_JSQR_JEXTSEL_Msk;

	// Set channels and seqeunce length
	uint32_t reg{0};
	for (auto [i, channel] : enumerate(channels))
	{
		reg |= (static_cast<uint8_t>(channel) & 0b11111) << (9 + (6 * i));
	}
	ADC{{ id }}->JSQR |= reg | (channels.size() - 1);

	return true;
}


inline bool
modm::platform::Adc{{ id }}::setSequenceChannel(const int index, const Channel channel)
{
	if(static_cast<uint8_t>(channel) > 18) {
		return false;
	}

	// index==0 -> SQR1
	if(index <= 4) {
		sqr1 |= (static_cast<uint8_t>(channel) & 0b11111) << (6 * (index + 1));
	}
	else if(index <= 9) {
		sqr2 |= (static_cast<uint8_t>(channel) & 0b11111) << (6 * (index - 4));
	}
	else if(index <= 14) {
		sqr3 |= (static_cast<uint8_t>(channel) & 0b11111) << (6 * (index - 9));
	}
	else if(index <= 16) {
		sqr4 |= (static_cast<uint8_t>(channel) & 0b11111) << (6 * (index - 14));
	}
	else {
		return false;
	}
	return true;
}

bool
modm::platform::Adc{{ id }}::setChannelSampleTime(const Channel channel,
	const SampleTime sampleTime)
{
	uint32_t tmpreg;
	if (static_cast<uint8_t>(channel) <= 9) {
		tmpreg = ADC{{ id }}->SMPR1
			& ((~ADC_SMPR1_SMP0) << (static_cast<uint8_t>(channel) * 3));
		tmpreg |= static_cast<uint32_t>(sampleTime) <<
						(static_cast<uint8_t>(channel) * 3);
		ADC{{ id }}->SMPR1 = tmpreg;
	}
	else if (static_cast<uint8_t>(channel) <= 18) {
		tmpreg = ADC{{ id }}->SMPR2
			& ((~ADC_SMPR2_SMP10) << ((static_cast<uint8_t>(channel)-10) * 3));
		tmpreg |= static_cast<uint32_t>(sampleTime) <<
						((static_cast<uint8_t>(channel)-10) * 3);
		ADC{{ id }}->SMPR2 = tmpreg;
	}
	else {
		return false;
	}
	return true;
}

void
modm::platform::Adc{{ id }}::setFreeRunningMode(const bool enable)
{
	if (enable) {
		ADC{{ id }}->CFGR |=  ADC_CFGR_CONT; // set to continuous mode
	} else {
		ADC{{ id }}->CFGR &= ~ADC_CFGR_CONT; // set to single mode
	}
}

void
modm::platform::Adc{{ id }}::setTrigger(const TriggerMode mode,
	const TriggerSourceRegular source)
{
	ADC{{ id }}->CFGR =
		(ADC{{ id }}->CFGR & ~(ADC_CFGR_EXTSEL_Msk | ADC_CFGR_EXTEN_Msk))
		| (static_cast<uint32_t>(mode) << ADC_CFGR_EXTEN_Pos)
		| (static_cast<uint32_t>(source) << ADC_CFGR_EXTSEL_Pos);
}

void
modm::platform::Adc{{ id }}::setInjectedTrigger(const TriggerMode mode,
	const TriggerSourceInjected source)
{
	ADC{{ id }}->JSQR =
		(ADC{{ id }}->JSQR & ~(ADC_JSQR_JEXTSEL_Msk | ADC_JSQR_JEXTEN_Msk))
		| (static_cast<uint32_t>(mode) << ADC_JSQR_JEXTEN_Pos)
		| (static_cast<uint32_t>(source) << ADC_JSQR_JEXTSEL_Pos);
}


void
modm::platform::Adc{{ id }}::startConversion(void)
{
	// TODO: maybe add more interrupt flags
	acknowledgeInterruptFlags(InterruptFlag::EndOfRegularConversion |
			InterruptFlag::EndOfSampling | InterruptFlag::Overrun);
	// starts single conversion for the regular group
	ADC{{ id }}->CR |= ADC_CR_ADSTART;
}


void
modm::platform::Adc{{ id }}::startInjectedConversion(void)
{
	// TODO: maybe add more interrupt flags
	acknowledgeInterruptFlag(InterruptFlag::EndOfSampling | InterruptFlag::Overrun);
	// starts single conversion for the regular group
	ADC{{ id }}->CR |= ADC_CR_JADSTART;
}

bool
modm::platform::Adc{{ id }}::isConversionFinished(void)
{
	return static_cast<bool>(getInterruptFlags() & InterruptFlag::EndOfRegularConversion);
}

uint16_t
modm::platform::Adc{{ id }}::getInjectedValue(uint8_t index)
{
	switch(index){
		case 1:
			return ADC{{ id }}->JDR1;
		case 2:
			return ADC{{ id }}->JDR2;
		case 3:
			return ADC{{ id }}->JDR3;
		case 4:
			return ADC{{ id }}->JDR4;
		default:
			return 0;
	}
}

template<uint8_t index>
uint16_t
modm::platform::Adc{{ id }}::getInjectedValue()
{
	static_assert(maxInjectedSequenceLength == 4, "Invalid maxInjectedSequenceLength");
	static_assert(index <= 4, "There are only 4 injected ADC values.");

	if constexpr(index == 1) {
		return ADC{{ id }}->JDR1;
	}
	else if constexpr(index == 2){
		return ADC{{ id }}->JDR2;
	}
	else if constexpr(index == 3){
		return ADC{{ id }}->JDR3;
	}
	else if constexpr(index == 4){
		return ADC{{ id }}->JDR4;
	}
}

// ----------------------------------------------------------------------------
// TODO: move this to some shared header for all cortex m3 platforms
// Re-implemented here to save some code space. As all arguments in the calls
// below are constant the compiler is able to calculate everything at
// compile time.

#ifndef MODM_CUSTOM_NVIC_FUNCTIONS
#define MODM_CUSTOM_NVIC_FUNCTIONS

static modm_always_inline void
nvicEnableInterrupt(const IRQn_Type IRQn)
{
	NVIC->ISER[(static_cast<uint32_t>(IRQn) >> 5)] =
								(1 << ((uint32_t)(IRQn) & 0x1F));
}

static modm_always_inline void
nvicDisableInterrupt(IRQn_Type IRQn)
{
	NVIC_DisableIRQ(IRQn);
}

#endif // MODM_CUSTOM_NVIC_FUNCTIONS

void
modm::platform::Adc{{ id }}::enableInterruptVector(const uint32_t priority,
												const bool enable)
{
%% if id <= 2
	const IRQn_Type INTERRUPT_VECTOR = ADC1_2_IRQn;
%% elif id <= 5
	const IRQn_Type INTERRUPT_VECTOR = ADC{{ id }}_IRQn;
%% endif

	if (enable) {
		NVIC_SetPriority(INTERRUPT_VECTOR, priority);
		nvicEnableInterrupt(INTERRUPT_VECTOR);
	} else {
		NVIC_DisableIRQ(INTERRUPT_VECTOR);
	}
}

void
modm::platform::Adc{{ id }}::enableInterrupt(const Interrupt_t interrupt)
{
	ADC{{ id }}->IER |= interrupt.value;
}

void
modm::platform::Adc{{ id }}::disableInterrupt(const Interrupt_t interrupt)
{
	ADC{{ id }}->IER &= ~interrupt.value;
}

modm::platform::Adc{{ id }}::InterruptFlag_t
modm::platform::Adc{{ id }}::getInterruptFlags()
{
	return InterruptFlag_t(ADC{{ id }}->ISR);
}

void
modm::platform::Adc{{ id }}::acknowledgeInterruptFlags(const InterruptFlag_t flags)
{
	// Flags are cleared by writing a one to the flag position.
	// Writing a zero is ignored.
	ADC{{ id }}->ISR = flags.value;
}
