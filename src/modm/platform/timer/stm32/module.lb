#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (c) 2016-2018, Niklas Hauser
#
# This file is part of the modm project.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# -----------------------------------------------------------------------------

from collections import defaultdict
props = {}

def get_connectors(instance):
    if instance in [1, 8]:
        return ["Channel1", "Channel1N", "Channel2", "Channel2N",
                "Channel3", "Channel3N", "Channel4", "Channel4N",
                "ExternalTrigger", "BreakIn"]
    elif instance in [2, 3, 4, 5, 19]:
        return ["Channel1", "Channel2", "Channel3", "Channel4", "ExternalTrigger"]
    elif instance in [9, 12]:
        return ["Channel1", "Channel2"]
    elif instance in [10, 11, 13, 14]:
        return ["Channel1"]
    elif instance in [15, 16, 17]:
        return ["Channel1", "Channel1N", "Channel2", "BreakIn"]
    return []

class Instance(Module):
    def __init__(self, device, instance):
        self.device = device
        self.instance = instance
        self.vectors = None
        self.type = "general_purpose"
        if self.instance.number in [1, 8, 20]:
            self.type = "advanced"
        elif self.instance.number in [6, 7, 18]:
            self.type = "basic"

    def init(self, module):
        module.name = self.instance.name
        module.description = "Instance {}".format(self.instance)

    def prepare(self, module, options):
        return True

    def validate(self, env):
        vecmap = {
            "_UP": ["Update"],
            "_TRG": ["Trigger"],
            "_BRK": ["Break"],
            "_COM": ["COM"],
            "_CC": ["CaptureCompare1", "CaptureCompare2",
                     "CaptureCompare3", "CaptureCompare4"],
        }
        vectors = list(self.device.core.vectors(lambda v: "TIM"+self.instance.name in v.split("_")))
        self.vectors = {irq:[] for irq in vectors}
        for irq in self.vectors.keys():
            for part, flags in vecmap.items():
                if part in irq:
                    self.vectors[irq].extend(flags)

        if len(self.vectors) == 0:
            raise ValidateException("No interrupts found for Timer{}! Possible IRQs are {}"
                                    .format(self.instance, list(self.device.core.vectors(lambda v: "TIM" in v))))
        if self.type != "advanced":
            if len(self.vectors) != 1:
                raise ValidateException("Timer{} is only allowed to have one IRQ! Found {}"
                                    .format(self.instance, self.vectors))


    def build(self, env):
        global props
        props["id"] = self.instance.number
        props["connectors"] = get_connectors(self.instance.number)
        props["vectors"] = self.vectors
        props["types"].add(self.type)

        env.substitutions = props
        env.outbasepath = "modm/src/modm/platform/timer"
        env.template("{}.hpp.in".format(self.type), "timer_{}.hpp".format(self.instance.name))
        env.template("{}.cpp.in".format(self.type), "timer_{}.cpp".format(self.instance.name))


def init(module):
    module.name = ":platform:timer"
    module.description = "Timers (TIM)"

def prepare(module, options):
    device = options[":target"]
    if not device.has_driver("tim:stm32*"):
        return False

    module.depends(
        ":architecture:register",
        ":cmsis:device",
        ":platform:gpio",
        ":platform:rcc")

    timers = device.drivers("tim")
    instances = []
    for driver in timers:
        for instance in driver.instances():
            module.add_submodule(Instance(device, instance))
            instances.append(instance.number)

    global props
    device = options[":target"]
    props["target"] = device.identifier
    props["types"] = set()

    return True

def build(env):
    global props
    env.substitutions = props
    env.outbasepath = "modm/src/modm/platform/timer"

    # Only generate the base types for timers that were generated
    types = props["types"]
    if "advanced" in types:
        types.add("general_purpose")
    if "general_purpose" in types:
        types.add("basic")
    for ttype in props["types"]:
        env.template("{}_base.hpp.in".format(ttype))

