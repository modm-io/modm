/*
 * Copyright (c) 2021, Thomas Sommer
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#pragma once
#include "spi_master.hpp"

#include <modm/platform.hpp>

template <modm::unsigned_integral_max32 T>
modm::ResumableResult<T>
modm::platform::SpiMaster{{ id }}::transmit(const T data)
{
 	// Interrupt enabled? transmission in progress!
	if(SPCR{{ id }} & (1 << SPIE)) {
		return {modm::rf::Running};
	} else if(!state.all(State::Idle)) {
		state.set(State::Idle);
		state.reset(State::Repeat);

		temp = data;
		tx.repeat = 0;
		tx_end.repeat = 1;

		setup_isr<T>();
		return {modm::rf::Running};
	}

	state.reset(State::Idle);

	return {modm::rf::Stop, T(temp | SPDR{{ id }})};
}

template <modm::unsigned_integral_max32 T>
modm::ResumableResult<void>
modm::platform::SpiMaster{{ id }}::transmit(const T data, std::size_t repeat)
{
	// Interrupt enabled? transmission in progress!
	if(SPCR{{ id }} & (1 << SPIE)) {
		return {modm::rf::Running};
	} else if(!state.all(State::Idle)) {
		state.set(State::Idle);
		state.set(State::Repeat);
		
		temp = data;
		tx.repeat = 0;
		tx_end.repeat = repeat;

		setup_isr<T>();
		return {modm::rf::Running};
	}

	state.reset(State::Idle);
	return {modm::rf::Stop};
}

template <modm::unsigned_integral_max32 T>
modm::ResumableResult<void>
modm::platform::SpiMaster{{ id }}::transmit(const T *tx_first, const T *tx_last, T *rx_first)
{
	modm_assert_continue_fail_debug(tx_first < tx_last, "SpiMaster::transmit", "tx_first > tx_last");
	modm_assert_continue_fail_debug(
		tx_last < rx_first
		|| rx_first + (tx_last - tx_first) <= tx_first,
		"SpiMaster::transmit", "rx overlaps tx"
	);
	
	// Interrupt enabled? transmission in progress!
	if(SPCR{{ id }} & (1 << SPIE)) {
		return {modm::rf::Running};
	} else if(!state.all(State::Idle)) {
		state.set(State::Idle);
		state.reset(State::Repeat);

		setup_isr<T>(tx_first, tx_last);
		return {modm::rf::Running};
	}

	state.reset(State::Idle);
	return {modm::rf::Stop};
}

template <std::unsigned_integral T>
void modm::platform::SpiMaster{{ id }}::setup_isr()
{
	if constexpr (std::is_same<T, uint8_t>::value)
	{
		DataType_t::set(state, DataType::Byte);
		// Transmit first byte
		SPDR{{ id }} = uint8_t(temp);
	}
	else if constexpr (std::is_same<T, uint16_t>::value)
	{
		DataType_t::set(state, DataType::HalfWord);
		shift = 1 * 8;
		// Transmit first byte
		SPDR{{ id }} = uint16_t(temp) >> shift;
	}
	else if constexpr (std::is_same<T, uint32_t>::value)
	{
		DataType_t::set(state, DataType::Word);
		shift = 3 * 8;
		// Transmit first byte
		SPDR{{ id }} = uint32_t(temp) >> shift;
	}
	// enable Interrupt
	SPCR{{ id }} |= (1 << SPIE);
}

template <std::unsigned_integral T>
void modm::platform::SpiMaster{{ id }}::setup_isr(const T *tx_first, const T *tx_last)
{
	if constexpr (std::is_same<T, uint8_t>::value)
	{
		DataType_t::set(state, DataType::Byte);
		tx.u8 = tx_first;
		tx_end.u8 = tx_last;
		// Transmit first byte
		SPDR{{ id }} = *tx.u8;
	}
	else if constexpr (std::is_same<T, uint16_t>::value)
	{
		DataType_t::set(state, DataType::HalfWord);
		tx.u16 = tx_first;
		tx_end.u16 = tx_last;
		shift = 1 * 8;
		// Transmit first byte
		SPDR{{ id }} = *tx.u16 >> shift;
	}
	else if constexpr (std::is_same<T, uint32_t>::value)
	{
		DataType_t::set(state, DataType::Word);
		tx.u32 = tx_first;
		tx_end.u32 = tx_last;
		if (rx.u32)
			*rx.u32 = 0;
		shift = 3 * 8;
		// Transmit first byte
		SPDR{{ id }} = *tx.u32 >> shift;
	}
	// enable Interrupt
	SPCR{{ id }} |= (1 << SPIE);
}