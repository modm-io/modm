/*
 * Copyright (c) 2013-2018, Niklas Hauser
 * Copyright (c) 2014, Sascha Schade
 * Copyright (c) 2017, Fabian Greif
 * Copyright (c) 2021, Thomas Sommer
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#include "spi_master.hpp"

#include <avr/io.h>
#include <avr/interrupt.h>

#include <modm/math/utils/bit_constants.hpp>
#include <modm/architecture/interface/atomic_lock.hpp>
#include <modm/architecture/interface/interrupt.hpp>

// ----------------------------------------------------------------------------

uint8_t modm::platform::SpiMaster{{ id }}::count(0);

void *modm::platform::SpiMaster{{ id }}::context(nullptr);

modm::Spi::ConfigurationHandler
modm::platform::SpiMaster{{ id }}::configuration(nullptr);

// ----------------------------------------------------------------------------
using State = modm::platform::SpiMaster::State;
using DataType = modm::platform::SpiMaster::DataType;

modm::platform::SpiMaster::State_t
modm::platform::SpiMaster{{ id }}::state(0);

uint8_t modm::platform::SpiMaster{{ id }}::shift(0);

uint32_t modm::platform::SpiMaster{{ id }}::temp(0);

modm::platform::SpiMaster{{ id }}::unsigned_types_const
	modm::platform::SpiMaster{{ id }}::tx{nullptr};

modm::platform::SpiMaster{{ id }}::unsigned_types_const
	modm::platform::SpiMaster{{ id }}::tx_end{nullptr};

modm::platform::SpiMaster{{ id }}::unsigned_types
	modm::platform::SpiMaster{{ id }}::rx{nullptr};

modm::platform::SpiMaster{{ id }}::unsigned_types
	modm::platform::SpiMaster{{ id }}::rx_end{nullptr};

// ----------------------------------------------------------------------------

MODM_ISR(SPI_STC)
{
	modm::platform::SpiMaster{{ id }}::isr_handler();
}

void modm::platform::SpiMaster{{ id }}::isr_handler()
{
	constexpr State_t state_normal = State::Idle;
	constexpr State_t state_repeat = State::Idle | State::Repeat;

	switch (state.value) {
	case state_normal.value | DataType::Byte:
		// Store received byte
		if (rx.u8)
			*rx.u8++ = SPDR{{ id }};
		if (++tx.u8 == tx_end.u8)
		{
			// Job done, disable Interrupt.
			SPCR{{ id }} &= ~(1 << SPIE);
			return;
		}
		// Transmit next byte
		SPDR{{ id }} = *tx.u8;
		return;
	case state_repeat.value | DataType::Byte:
		if(++tx.repeat == tx_end.repeat)
		{
			// Job done, disable Interrupt.
			SPCR{{ id }} &= ~(1 << SPIE);
			return;
		}
		// Transmit byte again
		SPDR{{ id }} = uint8_t(temp);
		return;
	case state_normal.value | DataType::HalfWord:
		if (shift)
		{
			// Store received byte
			if (rx.u8)
				*rx.u16 = uint16_t(SPDR{{ id }}) << 8; // << shift TODO ?? OK?
			// Transmit next byte
			shift = 0;
			SPDR{{ id }} = *tx.u16;
			return;
		}
		// Store received byte
		if (rx.u16)
			*rx.u16++ |= SPDR{{ id }};
		if (++tx.u16 == tx_end.u16)
		{
			// Job done, disable Interrupt.
			SPCR{{ id }} &= ~(1 << SPIE);
			return;
		}
		// Transmit next halfword
		shift = 1 * 8;
		SPDR{{ id }} = *tx.u16 >> shift;
		return;
	case state_repeat.value | DataType::HalfWord:
		if (shift)
		{
			// Transmit next sub-byte
			shift = 0;
			SPDR{{ id }} = uint16_t(temp);
			return;
		}
		if(++tx.repeat == tx_end.repeat)
		{
			// Job done, disable Interrupt.
			SPCR{{ id }} &= ~(1 << SPIE);
			return;
		}
		// Transmit halfword again
		shift = 1 * 8;
		SPDR{{ id }} = uint16_t(temp) >> shift;
		return;
	case state_normal.value | DataType::Word:
		if (shift)
		{
			// Store received sub-byte
			if (rx.u32)
				*rx.u32 |= uint32_t(SPDR{{ id }}) << shift;
			// Transmit next sub-byte
			shift -= 8;
			SPDR{{ id }} = *tx.u32 >> shift;
			return;
		}
		// Store received sub-byte
		if (rx.u32) {
			*rx.u32++ |= SPDR{{ id }};
			*rx.u32 = 0;
		}
		if (++tx.u32 == tx_end.u32)
		{
			// Job done, disable Interrupt.
			SPCR{{ id }} &= ~(1 << SPIE);
			return;
		}
		// Transmit next word
		shift = 3 * 8;
		SPDR{{ id }} = *tx.u32 >> shift;
		return;
	case state_repeat.value | DataType::Word:
		if (shift)
		{
			// Transmit next sub-byte
			shift -= 8;
			SPDR{{ id }} = uint32_t(temp) >> shift;
			return;
		}
		if(++tx.repeat == tx_end.repeat)
		{
			// Job done, disable Interrupt.
			SPCR{{ id }} &= ~(1 << SPIE);
			return;
		}
		// Transmit word again
		shift = 3 * 8;
		SPDR{{ id }} = uint32_t(temp) >> shift;
		return;
	}
}
// ---------------------------------------------------------------------------

uint8_t
modm::platform::SpiMaster{{ id }}::acquire(void *ctx, ConfigurationHandler handler)
{
	if (context == nullptr)
	{
		context = ctx;
		count = 1;
		// if handler is not nullptr and is different from previous configuration
		if (handler and configuration != handler) {
			configuration = handler;
			configuration();
		}
		return 1;
	}

	if (ctx == context)
		return ++count;

	return 0;
}

uint8_t
modm::platform::SpiMaster::release(void *ctx)
{
	if (ctx == context and --count == 0)
		context = nullptr;

	return count;
}

void modm::platform::SpiMaster{{ id }}::initialize(Prescaler prescaler)
{
	modm::atomic::Lock lock;

	SPCR{{ id }} = (1 << SPE) | (1 << MSTR) | (static_cast<uint8_t>(prescaler) & ~0x80);
	SPSR{{ id }} = (static_cast<uint8_t>(prescaler) & 0x80) ? (1 << SPI2X) : 0;
	state = State(0);
}