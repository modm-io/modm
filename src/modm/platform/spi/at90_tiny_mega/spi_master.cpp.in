/*
 * Copyright (c) 2013-2018, Niklas Hauser
 * Copyright (c) 2014, Sascha Schade
 * Copyright (c) 2017, Fabian Greif
 * Copyright (c) 2021, Thomas Sommer
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#include "spi_master.hpp"

#include <avr/io.h>
#include <avr/interrupt.h>

#include <modm/math/utils/bit_constants.hpp>
#include <modm/architecture/interface/atomic_lock.hpp>
#include <modm/architecture/interface/interrupt.hpp>

uint8_t modm::platform::SpiMaster{{ id }}::count(0);

void* modm::platform::SpiMaster{{ id }}::context(nullptr);

modm::Spi::ConfigurationHandler
	modm::platform::SpiMaster{{ id }}::configuration(nullptr);

// ----------------------------------------------------------------------------

modm::platform::Spi::State_t
	modm::platform::SpiMaster{{ id }}::state(0);
uint8_t modm::platform::SpiMaster{{ id }}::bytes_left(0);

std::size_t modm::platform::SpiMaster{{ id }}::size(0);
std::size_t modm::platform::SpiMaster{{ id }}::index(0);
modm::platform::SpiMaster{{ id }}::unsigned_data_u
	modm::platform::SpiMaster{{ id }}::tx{nullptr};
modm::platform::SpiMaster{{ id }}::unsigned_data_u
	modm::platform::SpiMaster{{ id }}::rx{nullptr};

uint32_t modm::platform::SpiMaster{{ id }}::temp(0);

// ----------------------------------------------------------------------------

using State = modm::platform::Spi::State;
using ByteCount = modm::platform::Spi::ByteCount;

MODM_ISR(SPI_STC) {
	modm::platform::SpiMaster{{ id }}::isr_handler();
}

void modm::platform::SpiMaster{{ id }}::isr_handler() {
	// Unpack state
	const int tx_byte_count = TxByteCount_t::get(state);
	const bool auto_incr = state.all(State::AutoIncr);

	// Transmit further byte(s)
	if(bytes_left) {
		const std::size_t i = auto_incr ? index : 0;
		switch(tx_byte_count) {
			case ByteCount::HalfWord:
				// Store received byte
				if(rx.u8) rx.u16[index] = uint16_t(SPDR{{ id }}) << 8; // << bytes_left
				// Transmit next byte
				bytes_left = 0;
				SPDR{{ id }} = tx.u16[i];
				return;
			case ByteCount::Word:
				// Store received byte
				if(rx.u8) rx.u32[index] |= uint32_t(SPDR{{ id }}) << bytes_left;
				// Transmit next byte
				bytes_left -= 8;
				SPDR{{ id }} = tx.u32[i] >> bytes_left;
				return;
		}
	}

	// Store received byte
	switch(tx_byte_count) {
		case ByteCount::Byte:
			if(rx.u8) rx.u8[index] = SPDR{{ id }};
			break;
		case ByteCount::HalfWord:
			if(rx.u8) rx.u16[index] |= SPDR{{ id }};
			break;
		case ByteCount::Word:
			if(rx.u8) rx.u32[index] |= SPDR{{ id }};
			break;
	}

	// Increment index
	if (++index == size) {
		// Job done, disable Interrupt.
		SPCR{{ id }} &= ~(1 << SPIE);
		return;
	}

	// Transmit next byte
	const std::size_t i = auto_incr ? index : 0;

	switch(tx_byte_count) {
		case ByteCount::Byte:
			SPDR{{ id }} = tx.u8[i];
			return;
		case ByteCount::HalfWord:
			bytes_left = 1 * 8;
			SPDR{{ id }} = tx.u16[i] >> 8; // >> bytes_left
			return;
		case ByteCount::Word:
			bytes_left = 3 * 8;
			SPDR{{ id }} = tx.u32[i] >> 24; // >> bytes_left
			
			if(rx.u32) rx.u32[index] = 0; // Need reset, because received bytes are | (ored)
			return;
	}
}

modm::ResumableResult<uint8_t>
modm::platform::SpiMaster{{ id }}::transmit(const uint8_t data) {
	// FIXME does not yet work when called before a regular transmit()
	// cause interrupt is not enabled here, witch signales a running condition
	// ot the regular transmit.

	// Interrupt enabled? transmission in progress!
	if(SPCR{{ id }} & (1 << SPIE))
		return {modm::rf::Running};

	SPDR{{ id }} = data;
	// wait for transfer to finish
	if (!(SPSR & (1 << SPIF)))
		return {modm::rf::Running};
	
	return {modm::rf::Stop, SPDR{{ id }}};
}

// ---------------------------------------------------------------------------

void modm::platform::SpiMaster{{ id }}::initialize(Prescaler prescaler)
{
	modm::atomic::Lock lock;

	SPCR{{ id }} = (1 << SPE) | (1 << MSTR) | (static_cast<uint8_t>(prescaler) & ~0x80);
	SPSR{{ id }} = (static_cast<uint8_t>(prescaler) & 0x80) ? (1 << SPI2X) : 0;
	state = State(0);
}

uint8_t
modm::platform::SpiMaster{{ id }}::acquire(void *ctx, ConfigurationHandler handler)
{
	if (context == nullptr)
	{
		context = ctx;
		count = 1;
		// if handler is not nullptr and is different from previous configuration
		if (handler and configuration != handler)
		{
			configuration = handler;
			configuration();
		}
		return 1;
	}

	if (ctx == context)
		return ++count;

	return 0;
}

uint8_t
modm::platform::SpiMaster{{ id }}::release(void *ctx)
{
	if (ctx == context and --count == 0)
		context = nullptr;

	return count;
}