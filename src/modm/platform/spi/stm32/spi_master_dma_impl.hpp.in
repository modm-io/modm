/*
 * Copyright (c) 2020, Mike Wolfram
 * Copyright (c) 2021, Thomas Sommer
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_SPI_MASTER{{ id }}_DMA_HPP
#	error 	"Don't include this file directly, use 'spi_master_{{ id }}_dma.hpp' instead!"
#endif

template <class DmaChannelRx, class DmaChannelTx>
template <class SystemClock, modm::baudrate_t baudrate, modm::percent_t tolerance>
void
modm::platform::SpiMaster{{ id }}_Dma<DmaChannelRx, DmaChannelTx>::initialize()
{
	// Configure the DMA channels, then calls SpiMaster{{ id }}::initialzie().
	Dma::RxChannel::configure(DmaBase::DataTransferDirection::PeripheralToMemory,
			DmaBase::MemoryDataSize::Byte, DmaBase::PeripheralDataSize::Byte,
			DmaBase::MemoryIncrementMode::Increment, DmaBase::PeripheralIncrementMode::Fixed,
			DmaBase::Priority::High);
	Dma::RxChannel::setPeripheralAddress(SPI{{ id }}_BASE + 0x0c);
	Dma::RxChannel::setTransferErrorIrqHandler(handleDmaTransferError);
	Dma::RxChannel::setTransferCompleteIrqHandler(handleDmaReceiveComplete);
	Dma::RxChannel::enableInterruptVector();
	Dma::RxChannel::enableInterrupt(DmaBase::InterruptEnable::TransferError |
			DmaBase::InterruptEnable::TransferComplete);
	Dma::RxChannel::template setPeripheralRequest<Dma::RxRequest>();

	Dma::TxChannel::configure(DmaBase::DataTransferDirection::MemoryToPeripheral,
			DmaBase::MemoryDataSize::Byte, DmaBase::PeripheralDataSize::Byte,
			DmaBase::MemoryIncrementMode::Increment, DmaBase::PeripheralIncrementMode::Fixed,
			DmaBase::Priority::High);
	Dma::TxChannel::setPeripheralAddress(SPI{{ id }}_BASE + 0x0c);
	Dma::TxChannel::setTransferErrorIrqHandler(handleDmaTransferError);
	Dma::TxChannel::setTransferCompleteIrqHandler(handleDmaTransmitComplete);
	Dma::TxChannel::enableInterruptVector();
	Dma::TxChannel::enableInterrupt(DmaBase::InterruptEnable::TransferError |
			DmaBase::InterruptEnable::TransferComplete);
	Dma::TxChannel::template setPeripheralRequest<Dma::TxRequest>();

	SpiMaster{{ id }}::initialize<SystemClock, baudrate, tolerance>();

	SpiHal{{ id }}::setRxFifoThreshold(SpiHal{{ id }}::RxFifoThreshold::QuarterFull);
}

template <class DmaChannelRx, class DmaChannelTx>
template <std::unsigned_integral T>
modm::ResumableResult<T>
modm::platform::SpiMaster{{ id }}_Dma<DmaChannelRx, DmaChannelTx>::transmit(T data)
{
	// this is a manually implemented "fast resumable function"
	// there is no context or nesting protection, since we don't need it.
	// there are only two states encoded into 1 bit (LSB of state):
	//   1. waiting to start, and
	//   2. waiting to finish.

	if (!state.all(SpiBase::LowByte))
	{
		// disable DMA for single transfer
		SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
				SpiBase::Interrupt::RxDmaEnable);

		// wait for previous transfer to finish
		if (!SpiHal{{ id }}::isTransmitRegisterEmpty())
			return {modm::rf::Running};

		// start transfer by copying data into register
		SpiHal{{ id }}::write(data);

		// set LSB = Bit0
		state.set(SpiBase::LowByte);
	}

	if (!SpiHal{{ id }}::isReceiveRegisterNotEmpty())
		return {modm::rf::Running};

	SpiHal{{ id }}::read(data);

	// transfer finished
	state.reset(SpiBase::LowByte);
	return {modm::rf::Stop, data};
}

template <class DmaChannelRx, class DmaChannelTx>
template <std::unsigned_integral T>
modm::ResumableResult<void>
modm::platform::SpiMaster{{ id }}_Dma<DmaChannelRx, DmaChannelTx>::transmit(const T *tx,
		const uint16_t repeat)
{
	// this is a manually implemented "fast resumable function"
	// there is no context or nesting protection, since we don't need it.
	// there are only two states encoded into 1 bit (Bit1 of state):
	//   1. initialize index, and
	//   2. wait for transfer to finish.

	switch(int(state.all(SpiBase::Idle)))
	{
	case 0:
		// we will only visit this state once
		state.set(SpiBase::Idle);
		dmaError = false;

		SpiHal{{ id }}::enableInterrupt(SpiBase::Interrupt::TxDmaEnable |
				SpiBase::Interrupt::RxDmaEnable);

		Dma::TxChannel::setMemoryAddress(uint32_t(tx));
		Dma::TxChannel::setMemoryIncrementMode(false);

		// Althought not used, RxChannel must be treated to keep the (current) Spi-Dma logic alive
		Dma::RxChannel::setMemoryAddress(uint32_t(&dmaDummy));
		Dma::RxChannel::setMemoryIncrementMode(false);

		Dma::TxChannel::setDataLength(repeat);
		dmaTransmitComplete = false;
		Dma::TxChannel::start();

		Dma::RxChannel::setDataLength(repeat);
		Dma::RxChannel::start();

		[[fallthrough]];

	default:
		while (true) {
			if (dmaError)
				break;
			if (not dmaTransmitComplete)
				return { modm::rf::Running };
			if (SpiHal{{ id }}::getInterruptFlags() & SpiBase::InterruptFlag::Busy)
				return { modm::rf::Running };
%% if "fifo" in features
			if (SpiHal{{ id }}::getInterruptFlags() & SpiBase::InterruptFlag::FifoTxLevel)
				return { modm::rf::Running };
%% endif
			break;
		}

		SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
				SpiBase::Interrupt::RxDmaEnable);
		
		state.reset(SpiBase::Idle);
		return {modm::rf::Stop};
	}
}

template <class DmaChannelRx, class DmaChannelTx>
template <std::unsigned_integral T>
modm::ResumableResult<void>
modm::platform::SpiMaster{{ id }}_Dma<DmaChannelRx, DmaChannelTx>::transmit(const T *tx,
		T *rx, const uint16_t length)
{
	// this is a manually implemented "fast resumable function"
	// there is no context or nesting protection, since we don't need it.
	// there are only two states encoded into 1 bit (Bit1 of state):
	//   1. initialize index, and
	//   2. wait for transfer to finish.

	// we are only interested in Bit1
	switch(int(state.all(SpiBase::Idle)))
	{
	case 0:
		// we will only visit this state once
		state.set(SpiBase::Idle);
		dmaError = false;

		SpiHal{{ id }}::enableInterrupt(SpiBase::Interrupt::TxDmaEnable |
				SpiBase::Interrupt::RxDmaEnable);

		if (tx) {
			Dma::TxChannel::setMemoryAddress(uint32_t(tx));
			Dma::TxChannel::setMemoryIncrementMode(true);
		} else {
			Dma::TxChannel::setMemoryAddress(uint32_t(&dmaDummy));
			Dma::TxChannel::setMemoryIncrementMode(false);
		}

		if (rx) {
			Dma::RxChannel::setMemoryAddress(uint32_t(rx));
			Dma::RxChannel::setMemoryIncrementMode(true);
		} else {
			Dma::RxChannel::setMemoryAddress(uint32_t(&dmaDummy));
			Dma::RxChannel::setMemoryIncrementMode(false);
		}

		Dma::TxChannel::setDataLength(length);
		dmaTransmitComplete = false;
		Dma::TxChannel::start();

		Dma::RxChannel::setDataLength(length);
		dmaReceiveComplete = false;
		Dma::RxChannel::start();

		[[fallthrough]];

	default:
		while (true) {
			if (dmaError)
				break;
			if (not dmaTransmitComplete and not dmaReceiveComplete)
				return { modm::rf::Running };
			if (SpiHal{{ id }}::getInterruptFlags() & SpiBase::InterruptFlag::Busy)
				return { modm::rf::Running };
			if (SpiHal{{ id }}::getInterruptFlags() & SpiBase::InterruptFlag::FifoTxLevel)
				return { modm::rf::Running };
			if (SpiHal{{ id }}::getInterruptFlags() & SpiBase::InterruptFlag::FifoRxLevel)
				return { modm::rf::Running };
			break;
		}

		SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
				SpiBase::Interrupt::RxDmaEnable);
		
		state.reset(SpiBase::Idle);
		return {modm::rf::Stop};
	}
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}_Dma<DmaChannelRx, DmaChannelTx>::handleDmaTransferError()
{
	SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
			SpiBase::Interrupt::RxDmaEnable);
	Dma::TxChannel::stop();
	Dma::RxChannel::stop();
	dmaError = true;
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}_Dma<DmaChannelRx, DmaChannelTx>::handleDmaTransmitComplete()
{
	Dma::TxChannel::stop();
	dmaTransmitComplete = true;
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}_Dma<DmaChannelRx, DmaChannelTx>::handleDmaReceiveComplete()
{
	Dma::RxChannel::stop();
	dmaReceiveComplete = true;
}