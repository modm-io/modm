/*
 * Copyright (c) 2009, Martin Rosekeit
 * Copyright (c) 2009-2012, Fabian Greif
 * Copyright (c) 2010, Georgi Grinshpun
 * Copyright (c) 2012-2017, Niklas Hauser
 * Copyright (c) 2013, Kevin LÃ¤ufer
 * Copyright (c) 2014, Sascha Schade
 * Copyright (c) 2021, Thomas Sommer
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#include "spi_master_{{id}}.hpp"

uint8_t
modm::platform::SpiMaster{{ id }}::count(0);

void *
modm::platform::SpiMaster{{ id }}::context(nullptr);

modm::Spi::ConfigurationHandler
modm::platform::SpiMaster{{ id }}::configuration(nullptr);

// ----------------------------------------------------------------------------

modm::platform::SpiMaster{{ id }}::State_t
modm::platform::SpiMaster{{ id }}::state(0);

uint8_t modm::platform::SpiMaster{{ id }}::shift(0);

uint32_t modm::platform::SpiMaster{{ id }}::temp(0);

modm::platform::SpiMaster{{ id }}::unsigned_types_const
	modm::platform::SpiMaster{{ id }}::tx{nullptr};

modm::platform::SpiMaster{{ id }}::unsigned_types_const
	modm::platform::SpiMaster{{ id }}::tx_end{nullptr};

modm::platform::SpiMaster{{ id }}::unsigned_types
	modm::platform::SpiMaster{{ id }}::rx{nullptr};

modm::platform::SpiMaster{{ id }}::unsigned_types
	modm::platform::SpiMaster{{ id }}::rx_end{nullptr};

// ----------------------------------------------------------------------------

uint8_t
modm::platform::SpiMaster{{ id }}::acquire(void *ctx, ConfigurationHandler handler)
{
	if (context == nullptr)
	{
		context = ctx;
		count = 1;
		// if handler is not nullptr and is different from previous configuration
		if (handler and configuration != handler) {
			configuration = handler;
			configuration();
		}
		return 1;
	}

	if (ctx == context)
		return ++count;

	return 0;
}

uint8_t
modm::platform::SpiMaster{{ id }}::release(void *ctx)
{
	if (ctx == context)
	{
		if (--count == 0)
			context = nullptr;
	}
	return count;
}

MODM_ISR(SPI{{ id }}_EV)
{
	// TODO Required?
	// Spi::acknowledgeInterruptFlags();
	modm::platform::SpiMaster{{ id }}::isr_handler();
}

void modm::platform::SpiMaster{{ id }}::isr_handler()
{
	constexpr State_t state_normal = State::Idle;
	constexpr State_t state_repeat = State::Idle | State::Repeat;

	switch (state.value) {
	case state_normal.value | DataType::Byte:
		// Store received byte
		if (rx.u8)
			SpiHal{{ id }}::read(rx.u8++);
		if (++tx.u8 == tx_end.u8)
		{
			// Job done, disable Interrupt.
			SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxBufferEmpty);
			return;
		}
		// Transmit next byte
		SpiHal{{ id }}::write(*tx.u8);
		return;
	case state_repeat.value | DataType::Byte:
		if(++tx.repeat == tx_end.repeat)
		{
			// Job done, disable Interrupt.
			SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxBufferEmpty);
			return;
		}
		// Transmit byte again
		SpiHal{{ id }}::write(uint8_t(temp));
		return;
	case state_normal.value | DataType::HalfWord:
		// Store received halfword
		if (rx.u16)
			SpiHal{{ id }}::read(rx.u16++);
		if (++tx.u16 == tx_end.u16)
		{
			// Job done, disable Interrupt.
			SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxBufferEmpty);
			return;
		}
		// Transmit next halfword
		SpiHal{{ id }}::write(*tx.u16);
		return;
	case state_repeat.value | DataType::HalfWord:
		if(++tx.repeat == tx_end.repeat)
		{
			// Job done, disable Interrupt.
			SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxBufferEmpty);
			return;
		}
		// Transmit halfword again
		SpiHal{{ id }}::write(uint16_t(temp));
		return;
	case state_normal.value | DataType::Word:
		if (shift)
		{
			// Store received sub-halfword
			if (rx.u32)
				SpiHal{{ id }}::read((rx.u16 - 1)); // TODO confirm this targets the right address
			// Transmit next sub-byte
			shift = 0;
			SpiHal{{ id }}::write(uint16_t(*tx.u32));
			return;
		}
		// Store received sub-byte
		if (rx.u32)
			SpiHal{{ id }}::read((uint16_t*)(rx.u32++));
		if (++tx.u32 == tx_end.u32)
		{
			// Job done, disable Interrupt.
			SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxBufferEmpty);
			return;
		}
		// Transmit next word
		shift = 16;
		SpiHal{{ id }}::write(uint16_t(*tx.u32 >> shift));
		return;
	case state_repeat.value | DataType::Word:
		if (shift)
		{
			// Transmit next sub-byte
			shift = 0;
			SpiHal{{ id }}::write(uint16_t(*tx.u32));
			return;
		}
		if(++tx.repeat == tx_end.repeat)
		{
			// Job done, disable Interrupt.
			SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxBufferEmpty);
			return;
		}
		// Transmit word again
		shift = 16;
		SpiHal{{ id }}::write(uint16_t(*tx.u32 >> shift));
		return;
	}
}