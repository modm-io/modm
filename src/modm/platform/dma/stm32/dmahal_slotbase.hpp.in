/*
 * Copyright (c) 2018, Christopher Durand
 * Copyright (c) 2018, Raphael Lehmann
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_DMAHALSTREAMBASE_HPP
#define MODM_STM32_DMAHALSTREAMBASE_HPP

#include <stdint.h>
#include "../device.hpp"

#include <modm/architecture/interface/register.hpp>
#include <modm/utils/bit_constants.hpp>

namespace modm::platform
{

class DmaHalSlotInterface
{

public:
	virtual
	~DmaHalSlotInterface() = default;

	DmaHalSlotInterface() = default;

	DmaHalSlotInterface(const DmaHalSlotInterface&) = delete;
	DmaHalSlotInterface& operator=(const DmaHalSlotInterface&) = delete;

%% set pointer_types = [8, 16, 32]
%% for type in pointer_types
	virtual void
	memoryToPeripheral{{ type }}(uint{{ type }}_t* memory, volatile uint32_t* peripheral) = 0;
	virtual void
	peripheralToMemory{{ type }}(volatile uint32_t* peripheral, uint{{ type }}_t* memory) = 0;
	virtual void
	memoryToMemory{{ type }}(uint{{ type }}_t*, uint{{ type }}_t*) = 0;
%% if feature["double_buffer"]
	// with double buffering:
	virtual void
	memoryToPeripheral{{ type }}(uint{{ type }}_t* memory1, uint{{ type }}_t* memory2, volatile uint32_t* peripheral) = 0;
	virtual void
	peripheralToMemory{{ type }}(volatile uint32_t* peripheral, uint{{ type }}_t* memory1, uint{{ type }}_t* memory2) = 0;
%% endif
%% endfor

	virtual void
	setTransferLength(uint16_t length) = 0;

	enum class
	MemoryIncrementMode : uint32_t
	{
		Fixed 		= 0,
		Increment 	= {{ reg_prefix }}_MINC, ///< incremented according to MemoryDataSize
	};

	enum class
	PeripheralIncrementMode : uint32_t
	{
		Fixed 		= 0,
		Increment 	= {{ reg_prefix }}_PINC, ///< incremented according to PeripheralDataSize
	};

	virtual void
	setIncrement(PeripheralIncrementMode p, MemoryIncrementMode m) = 0;

	enum class
	Priority : uint8_t
	{
		Low = 0,
		Medium = 1,
		High = 2,
		VeryHigh = 3,
	};

	virtual void
	setPriority(Priority p) = 0;

	enum class Mode : uint8_t {
		Normal = 0,
		%% if feature["circular_mode"]
		CircularMode = 1,
		%% endif
	};
	virtual void
	setMode(Mode m) = 0;

	struct Context
	{
		intptr_t memoryAddress1;
		intptr_t memoryAddress2; // == 0x00000000 if double buffering is not used
		volatile uint32_t* peripheralAddress;
		uint16_t transferLength;
		uint8_t direction : 2;
		uint8_t memoryIncrementMode : 1;
		uint8_t peripheralIncrementMode : 1;
		uint8_t priority : 2;
	};
	virtual bool
	acquire(Context* context) = 0;
	// waits until isFinished() (if any transfer has ever been started)
	// stores the context once another driver acquires

	virtual void
	releaseLater() = 0;
	// releases instantly, DMA transfer may still be active

	virtual void
	stop() = 0;

	virtual void
	start() = 0;

	virtual void
	reset() = 0;

	virtual bool
	isFinished() = 0;

	enum class Peripheral {
		%% for p in peripherals
		{{ p }},
		%% endfor
	};

	virtual void
	connect(Peripheral p) = 0;

	enum class
	FeatureMap : uint8_t
	{
		DoubleBuffering		= Bit0,
		CircularMode		= Bit1,
		Bursts				= Bit2,
	};
	MODM_FLAGS8(FeatureMap);

	virtual bool
	isAvailable(Peripheral p, FeatureMap_t features) = 0;
};

class DmaHalSlotBase : public DmaHalSlotInterface
{
protected:
	// Enums
%% if feature["request_mux"]
	enum class
	Channel : uint32_t
	{
		Channel0 = 0b000,
		Channel1 = 0b001,
		Channel2 = 0b010,
		Channel3 = 0b011,
		Channel4 = 0b100,
		Channel5 = 0b101,
		Channel6 = 0b110,
		Channel7 = 0b111,
	};
%% endif

%% if feature["burst"]
	enum class
	MemoryBurstTransfer : uint32_t
	{
		Single 		= 0,
		Increment4 	= {{ reg_prefix }}_MBURST_0,
		Increment8 	= {{ reg_prefix }}_MBURST_1,
		Increment16 = {{ reg_prefix }}_MBURST_1 | {{ reg_prefix }}_MBURST_0,
	};
	enum class
	PeripheralBurstTransfer : uint32_t
	{
		Single 		= 0,
		Increment4 	= {{ reg_prefix }}_PBURST_0,
		Increment8 	= {{ reg_prefix }}_PBURST_1,
		Increment16 = {{ reg_prefix }}_PBURST_1 | {{ reg_prefix }}_PBURST_0,
	};
%% endif

	/// In direct mode (if the FIFO is not used)
	/// MSIZE is forced by hardware to the same value as PSIZE
	enum class
	MemoryDataSize : uint32_t
	{
		Byte 		= 0,
		Bit8 		= Byte,
		HalfWord 	= {{ reg_prefix }}_MSIZE_0,
		Bit16 		= HalfWord,
		Word 		= {{ reg_prefix }}_MSIZE_1,
		Bit32 		= Word,
	};

	enum class
	PeripheralDataSize : uint32_t
	{
		Byte 		= 0,
		Bit8 		= Byte,
		HalfWord 	= {{ reg_prefix }}_PSIZE_0,
		Bit16 		= HalfWord,
		Word 		= {{ reg_prefix }}_PSIZE_1,
		Bit32 		= Word,
	};

%% if type == "stm32-stream-channel"
	enum class
	DataTransferDirection : uint32_t
	{
		/// Source: DMA_SxPAR; Sink: DMA_SxM0AR
		PeripheralToMemory 	= 0,
		/// Source: DMA_SxM0AR; Sink: DMA_SxPAR
		MemoryToPeripheral 	= {{ reg_prefix }}_DIR_0,
		/// Source: DMA_SxPAR; Sink: DMA_SxM0AR
		MemoryToMemory 		= {{ reg_prefix }}_DIR_1,
	};
	static constexpr uint32_t DataTransferDirectionMask = {{ reg_prefix }}_DIR_0 | {{ reg_prefix }}_DIR_1;
%% elif type == "stm32-channel-request" or type == "stm32-channel"
	enum class
	DataTransferDirection : uint32_t
	{
		/// Source: DMA_CPARx; Sink: DMA_CMARx
		PeripheralToMemory 	= 0,
		/// Source: DMA_CMARx; Sink: DMA_CPARx
		MemoryToPeripheral 	= DMA_CCR_DIR,
		/// Source: DMA_CPARx; Sink: DMA_CMARx
		MemoryToMemory 		= DMA_CCR_MEM2MEM,
	};
	static constexpr uint32_t DataTransferDirectionMask = DMA_CCR_DIR | DMA_CCR_MEM2MEM;
%% endif

protected:
%% if type == "stm32-stream-channel"
	static constexpr uint32_t memoryMask =
			{{ reg_prefix }}_MBURST_1 | {{ reg_prefix }}_MBURST_0 |	// MemoryBurstTransfer
			{{ reg_prefix }}_MSIZE_0  | {{ reg_prefix }}_MSIZE_1  |	// MemoryDataSize
			{{ reg_prefix }}_MINC                         |	// MemoryIncrementMode
			{{ reg_prefix }}_DIR_0    | {{ reg_prefix }}_DIR_1;    	// DataTransferDirection
	static constexpr uint32_t peripheralMask =
			{{ reg_prefix }}_PBURST_1 | {{ reg_prefix }}_PBURST_0 |	// PeripheralBurstTransfer
			{{ reg_prefix }}_PSIZE_0  | {{ reg_prefix }}_PSIZE_1  |	// PeripheralDataSize
			{{ reg_prefix }}_PINC                         |	// PeripheralIncrementMode
			{{ reg_prefix }}_DIR_0    | {{ reg_prefix }}_DIR_1;    	// DataTransferDirection
	static constexpr uint32_t configmask =
			{{ reg_prefix }}_CHSEL_2 | {{ reg_prefix }}_CHSEL_1 | {{ reg_prefix }}_CHSEL_0 |	// Channel
			{{ reg_prefix }}_PL_1    | {{ reg_prefix }}_PL_0    |						// Priority
			{{ reg_prefix }}_CIRC    |											// CircularMode
			{{ reg_prefix }}_PFCTRL;											// FlowControl
%% elif type == "stm32-channel-request"
	static constexpr uint32_t memoryMask =
			DMA_CCR_MSIZE_0  | DMA_CCR_MSIZE_1  |	// MemoryDataSize
			DMA_CCR_MINC                        |	// MemoryIncrementMode
			DMA_CCR_DIR      | DMA_CCR_MEM2MEM; 	// DataTransferDirection
	static constexpr uint32_t peripheralMask =
			DMA_CCR_PSIZE_0  | DMA_CCR_PSIZE_1  |	// PeripheralDataSize
			DMA_CCR_PINC                        |	// PeripheralIncrementMode
			DMA_CCR_DIR      | DMA_CCR_MEM2MEM;  	// DataTransferDirection
	static constexpr uint32_t configmask =
			DMA_CCR_CIRC     |						// CircularMode
			DMA_CCR_PL_1     | DMA_CCR_PL_0;		// Priority
%% endif
};

}	// namespace modm::platform

#endif	// MODM_STM32_DMAHALSTREAMBASE_HPP
