#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (c) 2016-2017, Niklas Hauser
# Copyright (c) 2017, Fabian Greif
#
# This file is part of the modm project.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# -----------------------------------------------------------------------------

from collections import defaultdict, OrderedDict
from pprint import pprint as pp

# Make string to CamelCase
def translate(s):
    name = ""
    for tok in s.split("_"):
        name += tok.capitalize()
    return name

# Get CamelCased name of driver
def get_driver(s):
    name = "None"
    if "driver" in s: name = translate(s["driver"]);
    if "instance" in s: name += translate(s["instance"]);
    return name

# Get CamelCased name
def get_name(s):
    return translate(s["name"])

# Create list of CamelCased names from signal list
def extract_signals(signals):
    afs = {}
    for s in signals:
        driver = get_driver(s)
        name = get_name(s)
        key = driver + name
        afs[key] = {"driver": driver, "name": name, "af": s["af"]}
    return afs


# -----------------------------------------------------------------------------

bprops = {}

def init(module):
    module.name = ":platform:gpio"
    module.description = "General Purpose I/O (GPIO) of NXP LPC devices"

def prepare(module, options):
    device = options[":target"]
    if not device.has_driver("gpio:lpc"):
        return False

    # ToDo: Derive from device
    bprops["ports"] = [ "PIO_0", "PIO_1", "PIO_2", "PIO_3" ]

    module.depends(
        ":platform:core",
        ":architecture:gpio",
        ":utils",
        ":platform:gpio.common",
        ) # ":platform:gpio.common") #, ":platform:i2c.generic")
    return True

def validate(env):
    device = env[":target"]
    driver = device.get_driver("gpio")

    all_signals = {}
    for gpio in driver["gpio"]:
        key = gpio["port"] + "_" + gpio["pin"]
        raw_signals = gpio["signal"] if "signal" in gpio else []
        for signal in raw_signals:
            if "af" in signal:
                signal["af"] = [signal["af"]]
            else:
                signal["af"] = []

        gpio["signal"] = raw_signals
        extracted_signals = extract_signals(raw_signals)
        print("extracted_signals for {}:".format(key))
        pp(extracted_signals)

        all_signals.update(extracted_signals)
        signal_names = sorted(list(set(s["name"] for s in extracted_signals.values())))
        extracted_signals = OrderedDict([(name, sorted([s for s in extracted_signals.values() if s["name"] == name], key=lambda si:si["name"])) for name in signal_names])


        gpio["functions"] = gpio["func"].lower().split(',')

        bprops[key] = {
            "gpio": gpio,
            # "exti_irqn": extimap[gpio["pin"]],
            "signals": extracted_signals,
        }
    all_peripherals = [s["driver"] for s in all_signals.values()]

    bprops["all_peripherals"] = sorted(list(set(all_peripherals)))
    bprops["all_signals"] = sorted(list(set(s["name"] for s in all_signals.values())))

    print('All peripherals:')
    pp(bprops["all_peripherals"])
    print('All signals:')
    pp(bprops["all_signals"])


def build(env):
    device = env[":target"]
    driver = device.get_driver("gpio")
    properties = device.properties
    properties["target"] = target = device.identifier
    properties["driver"] = driver
    properties.update(bprops)

    env.substitutions = properties
    env.outbasepath = "modm/src/modm/platform/gpio"
    gpio_source = "pin.hpp.in"

    for gpio in driver["gpio"]:
        pp(gpio)
        key = gpio["port"] + "_" + gpio["pin"]
        properties.update(bprops[key])
        header_name = "gpio_{}.hpp".format(key)
        env.template(gpio_source, header_name)

    env.template("gpio.hpp.in")
    env.template("base.hpp.in")
    env.template("unused.hpp.in")
    env.template("software_port.hpp.in")
    env.copy("gpio_enable.cpp")

    # FIXME: Move to modm:platform:core!
    env.outbasepath = "modm/src/modm/platform/core"
    env.template("peripherals.hpp.in")
