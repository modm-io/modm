/*
 * Copyright (c) 2018, Niklas Hauser
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_LPC_GPIO_SOFTWARE_PORT_HPP
#define MODM_LPC_GPIO_SOFTWARE_PORT_HPP

// #include "set.hpp"
#include <type_traits>

namespace modm
{

namespace platform
{

/**
 * Create an up to 32-bit port from arbitrary pins.
 *
 * This class optimizes the data type for the `read()` and `write()` methods.
 * Supplying up to 8 Gpios will use `uint8_t`, up to 16 Gpios `uint16_t` and
 * up to 32 Gpios `uint32_t`.
 *
 * @note Since the bit order is explicitly given by the order of template arguments,
 *       this class only supports `DataOrder::Normal`.
 *       If you need reverse bit order, reverse the order of `Gpios`!
 *
 * @tparam Gpios	Up to 32 GpioIO classes, ordered MSB to LSB
 *
 * @author	Niklas Hauser
 * @ingroup	modm_platform_gpio
 */
template< class... Gpios >
class SoftwareGpioPort : public ::modm::GpioPort
{
	// using Set = GpioSet<Gpios...>;
public:
	// using Set::width;
	// static_assert(width <= 32, "Only a maximum of 32 pins are supported by this Port!");
	using PortType = uint32_t;
	// using PortType = std::conditional_t< (width > 8),
	// 				 std::conditional_t< (width > 16),
	// 									 uint32_t,
	// 									 uint16_t >,
	// 									 uint8_t >;
	static constexpr DataOrder getDataOrder()
	{ return ::modm::GpioPort::DataOrder::Normal; }

protected:


//

	// };
	// static constexpr int8_t shift_mask(uint8_t id, uint8_t pos) { return shift_masks[id][width - 1 - pos]; }
	// using Set::mask;
	// using Set::inverted;

public:
	static PortType isSet()
	{
		PortType r{0};
		return r;
	}

	static void setOutput()
	{
		// set(status);
		// setOutput();
	}

	static void write(PortType /* data */)
	{
	}

	static PortType read()
	{
		PortType r{0};
		return r;
	}
};

} // namespace platform

} // namespace modm

#endif // MODM_LPC_GPIO_SOFTWARE_PORT_HPP
