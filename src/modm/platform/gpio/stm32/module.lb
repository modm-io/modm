#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (c) 2016-2018, Niklas Hauser
# Copyright (c) 2017, Fabian Greif
# Copyright (c) 2020, Christopher Durand
#
# This file is part of the modm project.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# -----------------------------------------------------------------------------

def init(module):
    module.name = ":platform:gpio"
    module.description = "General Purpose I/O (GPIO)"

def prepare(module, options):
    device = options[":target"]
    if not device.has_driver("gpio:stm32*"):
        return False

    ports = list(map(str.upper, device.gpio.ports))
    module.add_set_option(
        EnumerationOption(
            name="enable_ports",
            description="Enable clock for these GPIO ports during startup",
            enumeration=ports),
        default=ports)

    module.depends(
        ":architecture:gpio",
        ":cmsis:device",
        ":math:utils",
        ":platform:rcc")
    return True

def build(env):
    device = env[":target"]
    env.substitutions = {
        "target": device.identifier,
        "signal_remap": device.gpio.signals_remap,
        "ranges": device.gpio.ranges,
        "ports": list(map(str.upper, device.gpio.ports)),
        "signal_names": uniquify(s["name"] for s in device.gpio.signals_all),
        "pf": "1" if device.identifier.family in ["l4", "g0", "g4"] else "",
    }
    env.outbasepath = "modm/src/modm/platform/gpio"

    for (port, pin) in device.gpio.pins:
        has_remap = (port+str(pin)) in device.gpio.package_remap
        subs = {
            "port": port.upper(), "pin": pin,
            "exti_irqn": device.core.instance_irq_map("EXTI")[pin][0],
            "signals": device.gpio.signals_by_name(port, pin),
            "has_remap": has_remap,
        }
        if has_remap:
            reg, mask = get_remap_command(device.identifier.family, port+str(pin))
            subs.update({
                "remap_reg": reg,
                "remap_mask": mask,
                "remap_value": device.gpio.package_remap[port+str(pin)]
            })
        header_name = "gpio_{}{}.hpp".format(port.upper(), pin)
        env.template("pin.hpp.in", header_name, substitutions=subs, filters={
                     "to_adc_channel": lambda name: "".join(filter(str.isdigit, name))})

    env.template("port.hpp.in")
    env.template("software_port.hpp.in")
    env.template("set.hpp.in")
    if "f1" in device.gpio.type:
        env.template("connector_specialized.hpp.in",
                     substitutions={"group_map": device.gpio.signals_group},
                     filters={"printSignalMap": print_remap_group_table})
    env.template("base.hpp.in")
    env.template("unused.hpp.in")
    if len(env["enable_ports"]):
        env.template("enable.cpp.in")

    env.copy("../common/inverted.hpp", "inverted.hpp")
    env.copy("../common/connector.hpp", "connector.hpp")
    env.template("../common/connector_detail.hpp.in", "connector_detail.hpp")


# -----------------------------------------------------------------------------
def format_str(s):
    return "".join(p.capitalize() for p in str(s).split("_"))

def format_driver(s):
    return format_str(s.get("driver", "")) + format_str(s.get("instance", ""))

def print_remap_group_table(signal_map, peripheral):
    from collections import defaultdict
    per_signal_map = defaultdict(lambda : defaultdict(list))
    afs = []
    for key, signals in signal_map.items():
        for signal in signals:
            if format_driver(signal) == peripheral:
                for af in signal["group"]:
                    per_signal_map[key][str(af)].append(format_str(signal["name"]))
                afs.extend(map(str, signal["group"]))
    afs = uniquify(afs)

    array = [[peripheral] + afs]
    lengths = [len(s) for s in array[0]]
    for (port, pin) in sorted(per_signal_map):
        blub = [port.upper()+str(pin)] + [[] for _ in afs]
        for af, names in per_signal_map[(port, pin)].items():
            for name in names:
                blub[array[0].index(af)].append(name)
        blub = [",".join(b) if isinstance(b, list) else b for b in blub]
        lengths = [max(l, len(b)) for l, b in zip(lengths, blub)]
        array.append(blub)

    lines = []
    for i, vals in enumerate(array):
        line = []
        for j, text in enumerate(vals):
            line.append(text.center(lengths[j]+2))
        lines.append("|".join(line))
        if i == 0:
            lines.append("|".join(["-" * (lengths[j]+2) for j in range(len(array[0]))]))

    return lines

def get_remap_command(family, key):
    reg = 'SYSCFG->CFGR1'
    mask = {
        ('f0', 'a9') : 'SYSCFG_CFGR1_PA11_PA12_RMP',
        ('f0', 'a10'): 'SYSCFG_CFGR1_PA11_PA12_RMP',
        ('f0', 'a11'): 'SYSCFG_CFGR1_PA11_PA12_RMP',
        ('f0', 'a12'): 'SYSCFG_CFGR1_PA11_PA12_RMP',
        ('g0', 'a9') : 'SYSCFG_CFGR1_PA11_RMP',
        ('g0', 'a10'): 'SYSCFG_CFGR1_PA12_RMP',
        ('g0', 'a11'): 'SYSCFG_CFGR1_PA11_RMP',
        ('g0', 'a12'): 'SYSCFG_CFGR1_PA12_RMP',
    }.get((family, key))
    if mask is None:
        raise ValidateException("Unknown Remap for GPIO: 'P{}'".format(key.upper()))
    return (reg, mask)
