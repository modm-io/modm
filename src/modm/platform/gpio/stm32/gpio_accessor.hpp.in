/*
* Copyright (c) 2021, Christopher Durand
*
* This file is part of the modm project.
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_GPIO_ACCESSOR_HPP
#define MODM_STM32_GPIO_ACCESSOR_HPP

#include <array>

#include "../device.hpp"
#include "base.hpp"

namespace modm::platform
{

/**
* Type-erased Gpio wrapper
*
* Example:
* @code
*  GpioAccessor gpio = GpioAccessor::template fromGpio<GpioA1>();
*  gpio.toggle();
* @endcode
*
* @author	Christopher Durand
* @ingroup	modm_platform_gpio
*/
class GpioAccessor : public Gpio
{
private:
	// Store port as uintptr_t instead of GPIO_TypeDef*
	// because ST's GPIOx macros have an int-to-pointer cast
	// not possible during compile-time evaluation
	uintptr_t portAddress;
	uint16_t idBit;

	static consteval uintptr_t
	getPort(Port id)
	{
		switch (id)
		{
%% for port in ports
		case Port::{{ port | upper }}:
			return GPIO{{ port | upper }}_BASE;
%% endfor
		}
	}

	auto port() const { return reinterpret_cast<GPIO_TypeDef *>(portAddress); }

	constexpr GpioAccessor(uintptr_t port, uint8_t position)
		: portAddress{port}, idBit{uint16_t(1u << position)}
	{}

public:
	using PortType = GPIO_TypeDef *;

	GpioAccessor(PortType port, uint8_t position)
		: portAddress{reinterpret_cast<uintptr_t>(port)}, idBit{uint16_t(1u << position)}
	{}

	template<class Gpio>
	static constexpr GpioAccessor fromGpio()
	{
		static_assert(!Gpio::isInverted, "Inverted Gpios are not supported");
		return GpioAccessor{getPort(Gpio::port), Gpio::pin};
	}

	void set() const
	{
		port()->BSRR = idBit;
	}

	void reset() const
	{
		port()->BSRR = (idBit << 16);
	}

	void set(bool enable) const
	{
		if(enable) {
			set();
		} else {
			reset();
		}
	}

	bool isSet() const
	{
		return (port()->ODR & idBit);
	}

	void toggle() const
	{
		set(!isSet());
	}

	bool read() const
	{
		return (port()->IDR & idBit);
	}
};

template<typename... Gpios>
constexpr auto makeGpioArray()
{
	return std::array{ GpioAccessor::template fromGpio<Gpios>()... };
}

}

#endif // MODM_STM32_GPIO_ACCESSOR_HPP
