/*
 * Copyright (c) 2009, Martin Rosekeit
 * Copyright (c) 2009-2011, Fabian Greif
 * Copyright (c) 2011, Georgi Grinshpun
 * Copyright (c) 2012, 2014-2016, Niklas Hauser
 * Copyright (c) 2013, Kevin LÃ¤ufer
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

.text
	.syntax	unified
	.align	4
	.thumb

	// ------------------------------------------------------------------------
	/**
	 * @brief	Hard fault handler
	 *
	 * Prepares data for the C output handler
	 */
	.global	HardFault_Handler
	.type	HardFault_Handler, %function
	.thumb_func
	.func	HardFault_Handler
HardFault_Handler:
%% set timeout = 50 if "m0" in core else 25
%% if not "m0" in core
	/* When a hard fault occurs, this handler will move the stack pointer around.
 	 * This makes it harder to debug a hard fault with a real debugger, so if one is connected we would
	 * like to trigger a software breakpoint before moving the stack pointer.
	 * The decision to trigger the breakpoint needs to happen at runtime and not at compile time,
	 * since when a hard fault has been triggered, you want to debug the binary on the device and not
	 * compile a new binary with the breakpoint in it, which might then prevent the fault from occurring.
	 *
	 * The Cortex-M3 Core Debug module contains the "Debug Halting Control and Status Register" (DHCSR),
	 * which contains the `C_DEBUGEN` bit, which is set by the debugger to enable halting debug.
	 * "If halting debug is enabled [...], captured events will halt the processor in Debug state."
	 * You can test if halting debug is enabled using `(CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk)`.
	 *
	 * !!!WARNING:
	 *    "If DHCSR.C_DEBUGEN is clear and a breakpoint occurs in an NMI or HardFault exception handler,
	 *     the system locks up with an unrecoverable error."
	 *
	 * Since we are using a breakpoint inside the HardFault exception handler, we must therefore always
	 * check this flag, before executing the breakpoint.
	 *
	 * !!!WARNING:
	 *     On ARMv6-M "access to the DHCSR from software running on the processor is IMPLEMENTATION DEFINED."
	 *     This means, that on Cortex-M0, it might not be possible to read the DHCSR from software!
	 *
	 * Neither STM32F0 nor LPC11 implement this access!
	 *
	 * !!!WARNING:
	 *     OpenOcd does not reset the `C_DEBUGEN` bit on the `shutdown` command. This might be a bug.
	 *     A workaround is to issue `reset halt`, then manually reset the bits using `mww 0xE000EDF0 0xA05F0000`.
	 *     This will also clear the `C_HALT` bit and therefore this is equivalent to `reset run`.
	 *
	 * !!!WARNING:
	 *    `C_DEBUGEN` is sticky! It survives all resets but a power-on reset. This means that after debugging
	 *    either power cycle the target or manually clear `C_DEBUGEN` using `mww 0xE000EDF0 0xA05F0000`.
	 */
	mov lr, r0							// save register 0 into the link register
	ldr r0, =0xE000EDF0					// Load the address of the Debug Halting Control and Status Register (DHCSR)
	ldr r0, [r0, #0]					// load the content of DHCSR, we need to check if bit 0 is set
	lsls r0, #31						// test bit 0 by shifting it left 31 times, becoming sign bit
	mov r0, lr							// restore register 0 before triggering the breakpoint
	bpl no_debugger						// branch over breakpoint if lsls resulted in positive integer (MSB not set)

	ldr lr, =0xfffffff9					// restore link register for GDB
	bkpt #42							// trigger a break point, only if a debugger is connected

no_debugger:
%% endif

%% if options.behavior == "break"
	bkpt #42							// always trigger a break point
%% elif options.behavior == "wait"
	b HardFault_Handler					// busy wait in a loop forever
%% elif options.behavior == "reset"
	ldr r0, =_nvicSystemReset
	bx r0
%% else
	/* This sets up and toggles an LED.
	 * The actual setup and toggle code is delegated to C++ world,
	 * so that the modm GPIO API can be used.
	 * This consumes very, very little stack, definitely less than 32B.
	 * This code clobbers some registers, hopefully it was saved on exception entry.
	 */
	ldr r0, =_initHardFaultHandlerLed
	blx r0 								// call Led::setOutput();
loop:
	ldr r0, =_toggleHardFaultHandlerLed
	blx r0								// call Led::toggle();
	ldr r0, =500
	ldr r1, =_delay_ms
	blx r1								// call _delay_ms(500);
	b loop								// loop forever
%% endif
	.size	HardFault_Handler, . - HardFault_Handler
	.endfunc

	.end
